<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  <title>Complete Intro to React</title>
  <meta name="description" content="A Complete Intro to React, as taught for FrontendMasters.com
">
  <meta name="keywords" content="" />

  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" type="text/css" href="css/main.css" />
  <link rel="stylesheet" type="text/css" href="css/elements.css" />
  <link rel="stylesheet" type="text/css" href="css/layout.css" />
  <link rel="stylesheet" type="text/css" href="css/highlight.css" />
</head>
<body class="home-template">

  <header class="main-header">
    <div class="vertical">
      <div class="main-header-content">
        <h1 class="page-title">
          Complete Intro to React
        </h1>
      </div>
    </div>
  </header>

  <main id="content" class="content" role="main">
    


<article class="post">
  <section class="post-excerpt">
    <h1>This Course Has Been Updated: Go to the <a href="https://frontendmasters.com/learn/react/">React Learning Path</a> to find the latest version.</h1>
<h2>The code, website and materials for the new updated courses are always free and open source.</h2>
<h2>Welcome to <a href="https://frontendmasters.com/courses/react/">Complete Intro to React v3</a> (archived site).</h2>
<p>The goal of this workshop is to get you full up to speed on modern development and give you an idea what it is like to develop an app in the React ecosystem.</p>
<h3>The creation of this course is sponsored by <a href="https://frontendmasters.com/">Frontend Masters</a>. There are videos that go along with it and I encourage you to check them out.</h3>
<p>When talking about React, you cannot simply <em>just</em> use React. It is an incomplete picture; it is a cog in the machine. React does well to introduce some useful primitives into your toolbox and allows you to build your app without introducing too many opinions. As such, we need to learn some other tools to round the whole story of our app. However, keep in mind that these are modules we are choosing to plug together; you are free to go home and swap in your own parts to suit your own needs. While React fits many/most needs, this complete stack won't; it has opinions and you need to make sure each piece contributes to your story and try not to shoehorn any piece in that you don't need.</p>
<p>In addition to React, we are going to be using Node.js, Express, Redux, Webpack, Jest, Enzyme, Yarn, Prettier, ESLint, and React-Router. Don't worry if you're aren't familiar with any of these: that's the point of this workshop. Since this workshop is about React, we will not be deep diving into Node.js or database schema. We will discuss these satellite concepts just as they pertain to React.</p>
<p>Questions? Feel free to <a href="https://twitter.com/holtbt">tweet at me</a>. Corrections or concerns about this page? Please file an issue or make a pull request on <a href="https://github.com/btholt/complete-intro-to-react">the repo</a>.</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>In order to be able to complete this entire workshop, we need to go ahead and get some tools downloaded.</p>
<h2>Clone the git repo</h2>
<p><a href="https://github.com/btholt/complete-intro-to-react/tree/start">Click here</a> to go clone the <code>start</code></p>
<h2>node.js 6+</h2>
<p>You <em>probably</em> can complete this with something less than node 4 but I'm using v6.9.5. Being a Node.js LTS release, it's a safe bet to be using. If you need to use a different version of Node for work, I strongly recommend using <a href="https://github.com/creationix/nvm">nvm</a>. I recommend getting the binary straight off the <a href="https://nodejs.org/en/">Node website</a> and <em>not</em> using homebrew for installation.</p>
<h2>Yarn</h2>
<p>We're going to use <a href="https://yarnpkg.com/">Yarn</a> for this workshop. In practice this will be a little differences to you, but what's happening under the hood will be good for your app. Yarn will essentially replace your usage of the npm CLI client in your app. Instead of <code>npm install --save react</code> you'll run <code>yarn add react</code>. This installs the same package from the same npm registry (it runs through their own proxy but as of writing the <code>registry.yarnpkg.com</code> address is just a dumb passthrough.)</p>
<p>If you haven't installed yarn, install it via <code>npm install --global yarn</code>. You can also install it via homebrew: <code>brew update &amp;&amp; brew install yarn</code>.</p>
<p>Yarn does a couple of things different from npm. One, it's 100% deterministic. Deterministic is just a fancy way of saying that if you run yarn from any state, any time, 1000x times, it will still work the same way the 1001st time. npm's installs are nondeterministic. If you run it from various states, it will install different ways.</p>
<p>Yarn does some better caching too. In fact, it does it so well you'll see a <em>significant</em> reduction in your install times. Big code bases have seen a 10x reduction in install times.</p>
<p>Yarn also locks down your dependencies by default. It's possible to do this with an npm shrinkwrap command but if you've ever had to maintain one of those, it can be messy. This locking down of dependencies means you don't have to rely on npm authors doing <a href="http://semver.org/">semver</a> correctly, a notoriously controversial subject</p>
<h2>yarn installs</h2>
<p>Run <code>yarn</code> from the directory where you downloaded the repo. If you have node and npm installed, you should see a list of dependencies being installed.</p>
<h2>yarn global installs</h2>
<p>Run the following global npm installs</p>
<pre><code class="language-bash">yarn global add jest@v19.0.2
yarn global add nodemon
yarn global add webpack@v2.2.1
yarn global add prettier@v0.22.0
yarn global add eslint@v3.18.0
</code></pre>
<p>I have you install specific versions so that if the libraries change at all this workshop will all still apply. It doesn't really matter version of nodemon you use. You don't necessarily need these exact versions but you may run into issues if you use different major or minor releases as things make break between versions.</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>Welcome to the wonderful world of React. We are going to start with the most absolutely barebone version of React. No JSX. No ES6. No transpilation. Just pure component-oriented pleasure of coding.</p>
<p>So let's talk about what React is. I imagine most of those who take this class will come from another framework or library, be it jQuery, Angular, Backbone, Ember, Knockout, or something else. I will draw comparisons and contrasts to these other frameworks (despite not being the same, I'll be using the word library and framework interchangeably for brevity's sake) to help illuminate some of the differences but you needn't have programmed in these other frameworks to understand this workshop.</p>
<p>React is a library unto itself: it's not a full fledged framework like Ember or Backbone. It does not demand to own everything in the app. It can be happy being a side component on your page and being fed data into it. Some people like to bill React the <code>V</code> in <code>MVC</code> but this is selling it short; it's more than just a view. You can make full-fledged apps with just React and no other libraries. The concerns you would normally put into the model and controller can be done in React, and just as well outside of it. Its philosophy is more similar to Angular's: React gives you new primitives so you can construct your own applications / framework.</p>
<p>It bears mentioning that we are slowly going to build a full stack app progressively over the course of this workshop, piece-by-piece. By the end of the workshop, you'll have built a app that simulates the Netflix experience.</p>
<h2>My First Component!</h2>
<p>So let's start our first React code!</p>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vidflix<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"node_modules/react/dist/react.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"node_modules/react-dom/dist/react-dom.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">var</span> MyFirstComponent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> React.createElement(<span class="hljs-string">'div'</span>, <span class="hljs-literal">null</span>,
            React.createElement(<span class="hljs-string">'h1'</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"This is my first component!"</span>)
          );
        };

        ReactDOM.render(
          React.createElement(MyFirstComponent),
          <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"app"</span>)
        );
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h2>My Second Component</h2>
<p>Good job! You should see the text &quot;This is my first component!&quot; on the screen. As you may see, we constructed a bit of DOM using functions. That's all components are in React: functions. This ends up being a useful and powerful abstraction which you hopefully will see as we go on. This is about as simple as it gets as far as a React component goes. Let's take it one step further by nesting some components.</p>
<p>Notice we sort of have to two ideas in play here. <code>MyFirstComponent</code> ends up being a sort of blueprint, a rubber stamp for a type of components. When we call <code>React.createElement</code> we are creating one instance of <code>MyFirstComponent</code>, like we are stamping one stamp of it. We can create many <code>MyFirstComponents</code> using the same blueprint.</p>
<p>This method of creating components is called a stateless functional component. This is as opposed to the class version of a component which has more features. You'll see this later in the course as we keep going. Note that the <code>React.createClass</code> method of creating components is deprecated so we are moving on to the functions and classes versions of components. If you want to see the createClass version, see v1 and v2 of this workshop.</p>
<p>Before we start here, let's delete that bottom script tag in index.html and add <code>&lt;&amp;NegativeMediumSpace;script src=&quot;js/ClientApp.js&quot;&gt;&lt;/script&gt;</code> so we can get some good code separation going. Once done with that, create the js directory and add the ClientApp.js file. In this file, let's put</p>
<pre><code class="language-javascript"><span class="hljs-comment">/* global React ReactDOM */</span>

<span class="hljs-keyword">var</span> MyTitle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    React.createElement(<span class="hljs-string">'div'</span>, <span class="hljs-literal">null</span>,
      React.createElement(<span class="hljs-string">'h1'</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'Check out this component!'</span>)
    )
  );
};

<span class="hljs-keyword">var</span> MyFirstComponent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    React.createElement(<span class="hljs-string">'div'</span>, <span class="hljs-literal">null</span>,
      React.createElement(MyTitle, <span class="hljs-literal">null</span>),
      React.createElement(MyTitle, <span class="hljs-literal">null</span>),
      React.createElement(MyTitle, <span class="hljs-literal">null</span>)
    )
  );
};

ReactDOM.render(
  React.createElement(MyFirstComponent),
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"app"</span>)
);
</code></pre>
<p>Cool, right!</p>
<p><code>MyTitle</code> is a <code>ReactComponent</code> class. This is a stateless functional component that, once invoked, is expected to return a React element.</p>
<p>To invoke this function and create a new instance of the <code>MyTitle</code> component, you have to use the <code>React.createElement</code> method. The resulting instance is a <code>ReactElement</code>.</p>
<p>We can use this element the same way we use any other HTML-native tag. This allows us to encapsulate style, behavior, and markup into one neat little package and reuse these components everywhere!</p>
<p>To sum-up, we're making functions that create the component and then we're using <code>createElement</code> to create an <em>instance</em> of that class, resulting in an element that can be used in others components.</p>
<h2>Factories</h2>
<p>This is a bit verbose to write <code>React.createElement</code> so many damn times. Let's use a shortcut.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// replace MyFirstComponent</span>
<span class="hljs-keyword">var</span> ce = React.createElement;

<span class="hljs-comment">//replace MyFirstComponent's body</span>
<span class="hljs-keyword">return</span> (
  ce(<span class="hljs-string">'div'</span>, <span class="hljs-literal">null</span>,
    ce(MyTitleFact, <span class="hljs-literal">null</span>),
    ce(MyTitleFact, <span class="hljs-literal">null</span>),
    ce(MyTitleFact, <span class="hljs-literal">null</span>)
  )
);
</code></pre>
<p>This just helps us from having to write <code>React.createElement</code> so many times. There are DOM helpers and an additional package you can bring in that creates helper functions but in all honesty we're not going to use this way of creating React components once we get to using JSX.</p>
<h2>Props</h2>
<p>Our title component is cute but not super reuseable. Let's make it a bit more flexible by using some props. Props are variables that you pass from the parent to the child but the child cannot modify the props it gets. This simple restriction helps a lot in the future because when bugs arise, you know the child didn't modify the variable because it can't! Let's see how to do it.</p>
<p>Props are received as a parameter to stateless functional components and are on the <code>this</code> contextual object for stateful ES6 class components.</p>
<pre><code class="language-javascript"><span class="hljs-comment">/* global React ReactDOM */</span>

<span class="hljs-keyword">var</span> ce = React.createElement;

<span class="hljs-keyword">var</span> MyTitle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> (
    ce(<span class="hljs-string">'div'</span>, <span class="hljs-literal">null</span>,
      ce(<span class="hljs-string">'h1'</span>, <span class="hljs-literal">null</span>, props.title)
    )
  );
};

<span class="hljs-keyword">var</span> MyFirstComponent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    ce(<span class="hljs-string">'div'</span>, <span class="hljs-literal">null</span>,
      ce(MyTitle, {<span class="hljs-attr">title</span>: <span class="hljs-string">'House of Cards'</span>}),
      ce(MyTitle, {<span class="hljs-attr">title</span>: <span class="hljs-string">'Orange is the New Black'</span>}),
      ce(MyTitle, {<span class="hljs-attr">title</span>: <span class="hljs-string">'Stranger Things'</span>})
    )
  );
};

ReactDOM.render(
  ce(MyFirstComponent),
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"app"</span>)
);

</code></pre>
<p>Now we can change the contents of the title. But since we can pass in lots of props, we can widely differing elements of the same class based on what props are passed into the element. Let's take it a step further (and show you how to do inline styles and attributes with React.)</p>
<pre><code class="language-javascript"><span class="hljs-comment">// change MyTitle's inside h1</span>
ce(<span class="hljs-string">'h1'</span>, {<span class="hljs-attr">style</span>: {<span class="hljs-attr">color</span>: props.color}}, props.title)

<span class="hljs-comment">// change MyFirstComponent inside div</span>
ce(MyTitle, {<span class="hljs-attr">color</span>: <span class="hljs-string">'rebeccapurple'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'House of Cards'</span>}),
ce(MyTitle, {<span class="hljs-attr">color</span>: <span class="hljs-string">'peru'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'Orange is the New Black'</span>}),
ce(MyTitle, {<span class="hljs-attr">color</span>: <span class="hljs-string">'burlywood'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'Stranger Things'</span>})
</code></pre>
<p>Let's stop there and switch our attention a bit to tooling. So far we've been writing React with no compile step which is pretty cool and not something enough do in the course of React. Certain things will just make sense because you know what it complies to. In any case, onward!</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>Before we can introduce JSX to React, we are going to have to send it through a compilation step. So we are going to take a brief repose from React here to start working on our tooling a bit.</p>
<h2>Prettier</h2>
<p><a href="https://github.com/prettier/prettier">Prettier</a> is an amazing tool from the brain of <a href="https://twitter.com/jlongster">James Long</a>. James, like many of us, was sick of having to constantly worried about the style of his code: where to stick indents, how many, when to break lines, etc etc. Coming from languages like Go, Reason, or Elm where all that is just taken care of by the tooling for the language, this quickly wears. James did something about it and made a tool to take care of it: Prettier.</p>
<p>Prettier is a really fancy pretty printer. It takes the code you write, breaks it down in to an abstract syntax tree (AST) which is just a representation of your code. It then takes that AST, throws away all of your code style you made and prints it back out using a predefined style. While this sounds a little scary, it's actually really cool. Since you no longer have control of the style of your code, you no longer have to think at all about it. Your code is always consistent, as is the code from the rest of your team. No more bikeshedding!! As I like to put it: if your brain is a processor, you get to free up the thread of your brain that worries about code styles and readability: it just happens for you. Don't like semicolons? Don't write them! It puts them in for you. I <em>love</em> Prettier.</p>
<p>Need to tool around a bit with it before you trust it? <a href="https://prettier.github.io/prettier/">Go here</a>. You can see how it works.</p>
<p>Let's go integrate this into our project. It's pretty easy (lol.)</p>
<p>Either install Prettier globally <code>yarn global add prettier</code> (I'm using v0.22 as of writing) or replace when I run <code>prettier</code> with (from the root of your project) <code>./node_modules/.bin/prettier</code>. From there, run <code>prettier script.js</code>. This will output the formatted version of your file. If you want to actually write the file, run <code>prettier --write script.js</code>. Go check script.js and see it has been reformatted a bit. I will say for non-JSX React, prettier makes your code less readable. Luckily Prettier supports JSX! We'll get to that shortly.</p>
<p>Prettier has a few configurations but it's mostly meant to be a tool everyone uses and doesn't argue/bikeshed about the various code style rules. <a href="https://github.com/prettier/prettier#api">Here they are</a>. I'm going to use a print-width of 120 and single quotes because I like that better but you're welcome to leave it as-is too. Prettier also can understand <a href="https://flow.org/">flow</a> if you switch the parser but we're not going to worry about that. TypeScript support is coming.</p>
<h2>npm/Yarn scripts</h2>
<p>So it can be painful to try to remember the various CLI commands to run on your project, especially with Prettier because it doesn't have a config object yet (they're making one.) npm/Yarn scripts to the rescue! You can put CLI commands into it and then run the name of the tag and it'll run that script. Let's go see how that works. Put the following into your package.json.</p>
<pre><code class="language-json">"scripts": {
	"format": "prettier --list-different --single-quote --print-width=120 \"js/**/*.{js,jsx}\"",
},
</code></pre>
<p>Now you can run <code>yarn format</code> or <code>npm run format</code> and it will run that command. This means we don't have to remember that mess of a command and just have to remember format. Nice, right? We'll be leaning on this a lot during this course.</p>
<h2>Editor Integration</h2>
<p>This is all fun, but it's very manual. Let's go make this run automatically on save. This makes the whole process super seamless. For your editor's instructions, <a href="https://github.com/prettier/prettier#editor-integration">go here</a>. Once you've enabled it and put it run on autosave then we're good to go! Here's the config I used for Sublime:</p>
<pre><code class="language-json">{
	<span class="hljs-attr">"prettier_cli_path"</span>: <span class="hljs-string">"/Users/brholt/.nvm/versions/node/v6.9.5/bin/prettier"</span>,
	<span class="hljs-attr">"node_path"</span>: <span class="hljs-string">"/Users/brholt/.nvm/versions/node/v6.9.5/bin/node"</span>,
	<span class="hljs-attr">"auto_format_on_save"</span>: <span class="hljs-literal">true</span>
	<span class="hljs-string">"prettier_options"</span>: {
		<span class="hljs-attr">"parser"</span>: <span class="hljs-string">"babylon"</span>,
		<span class="hljs-attr">"singleQuote"</span>: <span class="hljs-literal">true</span>,
		<span class="hljs-attr">"printWidth"</span>: <span class="hljs-number">120</span>,
	}
}
</code></pre>
<h2>ESLint</h2>
<p>On top of Prettier which takes of all the formatting, you may want to enforce some code styles which pertain more to usage: for example you may want to force people never use <code>with</code> which is valid JS but illadvised to use. ESLint comes into play here. It will lint for this problems. There are dozens of present configs for ESLint and you're welcome to use any one of them. The Airbnb config is very popular, as is the standard config (which I teach in previous versions of this class.) We're going to use the Airbnb one since it's likely the most popular one. Let's create an <code>.eslintrc.json</code> file to start linting our project.</p>
<p>Create this file called <code>.eslintrc.json</code>.</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"extends"</span>: [
    <span class="hljs-string">"airbnb"</span>,
    <span class="hljs-string">"prettier"</span>,
    <span class="hljs-string">"prettier/react"</span>
  ],
  <span class="hljs-attr">"plugins"</span>: [
    <span class="hljs-string">"prettier"</span>
  ],
  <span class="hljs-attr">"parserOptions"</span>: {
    <span class="hljs-attr">"ecmaVersion"</span>: <span class="hljs-number">2016</span>,
    <span class="hljs-attr">"sourceType"</span>: <span class="hljs-string">"module"</span>,
    <span class="hljs-attr">"ecmaFeatures"</span>: {
      <span class="hljs-attr">"jsx"</span>: <span class="hljs-literal">true</span>
    }
  },
  <span class="hljs-attr">"env"</span>: {
    <span class="hljs-attr">"es6"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"browser"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"node"</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre>
<p>This is a combination of the recommended configs of Airbnb and Prettier. This will lint for both normal JS stuff as well as JSX stuff. Run <code>eslint script.js</code> now and you should see we have a few errors. Run it again with the <code>--fix</code> flag and see it will fix some of it for us! Go fix the rest of your errors and come back. Let's go add this to our npm scripts. If you haven't checked out <a href="https://github.com/airbnb/javascript">Airbnb's style guide</a> it's worth a read.</p>
<pre><code class="language-json">lint": "eslint **/*.{js,jsx} --quiet"
</code></pre>
<p>Worth adding three things here:</p>
<ul>
<li>With npm scripts, you can pass additional parameters to the command if you want. Just add a <code>--</code> and then put whatever else you want to tack on after that. For example, if I wanted to get the debug output from ESLint, I could run <code>yarn lint -- --debug</code> which would translate to <code>eslint **/*.js --debug</code>.</li>
<li>We can use our fix trick this way: <code>yarn lint -- --fix</code>.</li>
<li>We're going to both JS and JSX.</li>
</ul>
<p>You can linting and fixing to your editor too but I'll leave that to you. It can be a bit finnicky to get going. I'll be using <a href="http://sublimelinter.readthedocs.io/en/latest/">SublimeLinter</a> and <a href="https://github.com/roadhump/SublimeLinter-eslint">sublimelinter-contrib-eslint</a> (you need both.)</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>Now that we have clean code via a linter and can run our scripts courtesy of npm, let's work on the compilation / build of our code. In order to achieve this we are going to use two tools: Webpack and Babel.</p>
<h2>Webpack</h2>
<p>Webpack is an amazing tool that came out two or so years ago that captivated particularly the React crowd quick due to its ease and interesting features. We are going to only scratch the service of this powerful tool; you could give a whole workshop just on Webpack. We are going to lean on two of Webpack's core features: module compilation and the ability to plug in loaders.</p>
<p>As you saw with our code, it is pretty easy to put one or two components in one file. But what happens when you have an app as complex at Netflix that has hundreds, if not thousands, of components? Having just one file is untenable. You <em>could</em> just split them into separate files, make sure to load them in correct order, and keep a list of files in your HTML directory. But that sucks too, so we're going to introduce a build step that, while build steps suck, this will make things a bit easier.</p>
<p>For fun, split your MyTitle component from ClientApp.js into a new file, MyTitle.js. You will have to put the appropriate React.DOM helper methods in each file. At the bottom of MyTitle.js, add the line <code>export default MyTitle;</code>. At the top of ClientApp.js, put the line <code>import MyTitle from './MyTitle'</code>. Let's try to compile that.</p>
<p>You should have Webpack 2.3+ installed. Go to the directory of the project in the terminal . After that, run <code>webpack js/ClientApp.js public/bundle.js</code>. In your index.html, change the line of <code>&lt;&amp;NegativeMediumSpace;script src=&quot;js/ClientApp.js&quot;&gt;&lt;/script&gt;</code> to <code>&lt;&amp;NegativeMediumSpace;script src=&quot;/public/bundle.js&quot;&gt;&lt;/script&gt;</code>.</p>
<p>Try your browser again. bundle.js has all the stuff for both files now. Now we can keep components in their own files which is a huge win for organization. But wait, we can use Webpack for even greater code by using it to bring in node modules. In index.html, remove the other script tags so <em>just</em> bundle.js is left.</p>
<p>In ClientApp.js, remove the global comment at the top and add at the top</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { render } <span class="hljs-keyword">from</span> (<span class="hljs-string">'react-dom'</span>);

<span class="hljs-comment">// change render</span>
render(React.createElement(MyFirstComponent), <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'app'</span>));
</code></pre>
<p>In MyTitle, add:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// remove global comment, add at top</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-comment">// add to bottom</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> MyTitle;
</code></pre>
<p>Run your Webpack command again. Try your browser again. Despite only including bundle.js, the whole app works! If you look at Webpack, you'll see it's 99% React code and some of yours. Now we can go forth making new files and including new libraries without worrying about if they are being included!</p>
<p>Let's add build to our npm scripts. Add to scripts in package.json <code>&quot;build&quot;: &quot;Webpack js/ClientApp.js public/bundle.js&quot;,</code>. Run <code>yarn build</code> from your terminal in the project root directory and see if it works. Magic!</p>
<p>We're also using ES6 modules here, if you're not familiar with that syntax. The <code>import React from 'react'</code> is semantically identical to <code>var React = require('react')</code>. The <code>import { render } from 'react-dom'</code> as far as you're concerned here is identical to <code>var render = require('react-dom').render</code>. For further reading, checkout <a href="http://www.2ality.com/2014/09/es6-modules-final.html">2ality</a>'s post on it.</p>
<h2>Babel</h2>
<p>Babel is an amazing, amazing tool that has fundamentally altered the landscape of JavaScript as we know. Though they didn't invent the idea of transpiling future syntax of JavaScript into current syntax (thanks Traceur,) they did make it so damn <em>easy</em>. Couple that with the fact it worked with React's JSX (which we'll talk about in a sec) and it was a perfect storm the be massively successful. Babel, in short, is amazing and should be something you consider for every project.</p>
<p>Babel 6 (the latest revision of Babel) took away a tiny bit of that ease of use but in return it became much easier to develop which is important  when you're maintaining a massive project that's very important. In return it requires a bit of config now.</p>
<p>Create a new file called .babelrc. Inside .babelrc, put:</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"presets"</span>: [
    <span class="hljs-string">"react"</span>,
    [<span class="hljs-string">"env"</span>, {
      <span class="hljs-attr">"targets"</span>: {
        <span class="hljs-attr">"browsers"</span>: <span class="hljs-string">"last 2 versions"</span>
      },
      <span class="hljs-attr">"loose"</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">"modules"</span>: <span class="hljs-literal">false</span>
    }]
  ]
}
</code></pre>
<p>Babel has the concept of plugins. Each transformation comes in the form a plugin. However ES6 and React each have a number of transformation and it's a huge pain to include each one. Thus Babel has the concept of presets, or in other words bundles of plugins. In this case, we're including <em>all</em> of the React and many ES6 transformations. If this were a production app we would definitely go through and only include the transformations we needed and <em>not</em> all of them. For example, this includes a fairly large library to get ES6 generators working. Few people these days are actually using generators and thus it's better to leave them off if you don't need them. In our case, this is a teaching app so page weight isn't a big deal to us. This will also allow us to start using JSX.</p>
<p>However, we've taken this a step further by using [babel-preset-env][bpe]. babel-preset-env let's you specify your target (in our case we've targeted the last two major versions of each browser) and it only includes the necessary plugins necessary. What's amazing about this is that as we go forward and browsers can support more and more, we can start shipping ES6+ code to browsers! Amazing. It updates itself.</p>
<p>Also, we're telling Babel to <em>not</em> transform modules. New to Webpack 2 is the ability to do tree shaking. Tree shaking (also known as live code inclusion, as opposed to dead code elimination) is where you start with the entry point to your program (usually an index.js) and begin working outwards, only including the parts of code your code uses. Usually this doesn't buy you much in terms of <em>your</em> code; we tend to not write much dead code for our own apps. However it's extremely helpful for modules you're including. If you use lodash for one function, you don't want to include the whole library. Instead, you want your bundler to just include that barebones of what you need for to work. This is what Webpack 2 and Uglify buy for us; Webpack 2 bundles and Uglify takes the dead code paths out.</p>
<h2>Webpack loaders</h2>
<p>So, we could use the Babel CLI to compile our code but we are already using Webpack and Webpack has a good way to send your code through Babel via its loader mechanism. Loaders are utilities that Webpack will pipe input into and accept output out of. You can use loaders to transpile things like CoffeeScript, TypeScript, or PureScript. Webpack loaders can do some other powerful things like allowing you to <em>include</em> CSS, inline images via encoding, and transform SVGs. We're just going to be using the JS transformation abilities for now. Run the command <code>webpack --module-bind 'js=babel-loader' js/ClientApp.js public/bundle.js</code>. Should take a bit longer since it's doing more. Since we're going to be using Webpack for a few other things, let's abstract that configuration from inline to a config file. Add a <code>webpack.config.js</code> with the following.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">context</span>: __dirname,
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./js/ClientApp.js'</span>,
  <span class="hljs-attr">devtool</span>: <span class="hljs-string">'source-map'</span>,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.join(__dirname, <span class="hljs-string">'public'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>
  },
  <span class="hljs-attr">resolve</span>: {
    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">'.js'</span>, <span class="hljs-string">'.jsx'</span>, <span class="hljs-string">'.json'</span>]
  },
  <span class="hljs-attr">stats</span>: {
    <span class="hljs-attr">colors</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">reasons</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">chunks</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.jsx?$/</span>,
        <span class="hljs-attr">loader</span>: <span class="hljs-string">'babel-loader'</span>
      }
    ]
  }
};

</code></pre>
<p>What you see is essentially a config version of what we were doing with CLI flags. Now it's a bit more resilient and guaranteed consistent. If you run just the command <code>webpack</code> from your project directory you should get the same output. Neat. Go change you npm script to just be &quot;webpack&quot; now. Go try it and make sure it still works. Great! Good? Good. This should get us to a point now where we can talk about JSX.</p>
<p>At this point we need to make sure Prettier and ESLint ignore our compiled files: we don't care if those files are well formatted or linted. Create a new file called .eslintignore and put this in there:</p>
<pre><code>node_modules/
<span class="hljs-keyword">public</span>/
</code></pre>
<p>So let's also make the scripts remember build. Add this to your package.json.</p>
<pre><code class="language-json">"build": "webpack"
</code></pre>
<p>Okay! Let's keep going!</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>We have been writing our React with vanilla JavaScript up until now which frankly few people do. Most people take advantage of JSX which essentially adds HTML/XML-like syntax as a &quot;primitive&quot; type to JavaScript. In reality, what it does it takes the HTML you write for your components and translate them into the same calls we writing just using vanilla JavaScript.</p>
<p>So why JSX? People usually get pretty grossed out by the HTML in the JavaScript and say it looks like 1998 when we were still writing JavaScript in our HTML. However, I assert that markup in JS is a good thing while JS in markup is a bad thing! Here, we're keeping all the concerns of a component in one place: the markup structure, the event listeners, the state, the state mutators, everything. If the component breaks, we know it broke there. That's really valuable.</p>
<p>So try it. While the plain JS way isn't too bad, once you start writing JSX I <em>almost</em> guarantee you won't want to go back. Let's convert what we have to JSX.</p>
<p>Side note: good idea to install a JSX syntax highlighter. If you're using Sublime, I highly recommend the &quot;Babel&quot; package off of Package Control. If you're using VIM, try <a href="https://github.com/jordwalke/VimBox">VimBox</a>. I have no experience with it but I've heard it helps.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> MyTitle = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> style = { <span class="hljs-attr">color</span>: props.color };
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>&gt;</span>
        {props.title}
      <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> MyTitle;
</code></pre>
<p>We're using JSX finally! Make sure you're inserting those opening and closing parens around the component. It's just letting JS know you're going to put your expression on the next line (which we want to do for readability.)</p>
<p>Since we're using JSX now, we're going to rename our files to MyTitle.jsx and ClientApp.jsx. You could leave it as .js (I tend to in personal projects) but the Airbnb config of ESLint requires it. Make sure you change the entry in <code>webpack.config.js</code> to reflect JSX as the entry point.</p>
<p>Notice the curly braces surrounding <code>props.title</code>. They're there to let JSX know I want this to be a JS expression. If they weren't there, it would literally put the string 'props.title'. Notice the double curly braces surrounding the style value. The exterior set of curly braces are the same as the one as before: they're letting JSX know you want a JS expression. The interior set of curly braces represent a JavaScript object, meaning you're passing in a object to the style attribute. A little strange to get used to seeing that, but keep in mind that double curly braces themselves have no special meaning.</p>
<p>Lastly, you may notice that I switched to an ES6 style here. This is synonymous with the function syntax; just a bit more terse. Feel free to write it in any syntax that fits your fancy; this is very readable to me but may not be to you.</p>
<p>Let's rewrite ClientApp.jsx.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> MyTitle <span class="hljs-keyword">from</span> <span class="hljs-string">'./MyTitle'</span>;

<span class="hljs-keyword">const</span> MyFirstComponent = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;MyTitle title="Props are great!" color="rebeccapurple" /&gt;
      &lt;MyTitle title="Use props everywhere!" color="mediumaquamarine" /&gt;
      &lt;MyTitle title="Props are the best!" color="peru" /&gt;
    &lt;/div&gt;
  );
};

ReactDOM.render(&lt;MyFirstComponent /&gt;, document.getElementById('app'));
</code></pre>
<p>Notice how we use our own components as if they were normal HTML tags. Neat, right? We define our own components and then we can throw anywhere since they're self contained! We even pass them props as if they were normal attributes.</p>
<p>Also notice we're including React in both files but not directly manipulating it. This is okay since remember JSX is converting these tags to calls to React, so in reality it is using React (and thus we <em>do</em> have to include it.) Overall a simplification I think!</p>
<p>Something to make note of: the top level component has to be singular, or in other words, your top level component cannot be sibling to something else. This makes sense if you think about what JSX is transpiling to: function calls.</p>
<pre><code class="language-javascript">
// won't compile
const InvalidComponent = () =&gt; (
  &lt;h1&gt;My Title&lt;/h1&gt;
  &lt;h2&gt;My Title 2&lt;/h2&gt;
);

// will compile
const ValidComponent = () =&gt; (
  &lt;div&gt;
    &lt;h1&gt;My Title&lt;/h1&gt;
    &lt;h2&gt;My Title 2&lt;/h2&gt;
  &lt;/div&gt;
);

</code></pre>
<p>Hence why you'll see a lot of wrapping divs in JSX; it's so the whole thing will compile. This is fine if you need to do this; an extra wrapping div does nothing of harm unless you have structurally sensitive CSS. Also notice that if you have just raw text to put into JSX, you can enter it just as if was normal HTML. It's only when you have JS expressions when you need to use the curly braces.</p>
<p>Note this will change with React Fiber, which by the time you read this, may have been released. It's plan as shipping with React 16. Fiber is a total rewrite that's still API compatbile with React. With Fiber, you'll be able to render multiple top level components.</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>So let's actually discuss what we're going to build today: a basic Netflix experience. This is going to afford us several fun experiences and use cases to explore with our new-found stack. Our app is going to have a home page, a browse/search page, and a video page. Over the next few chapters we are going to be talking about Redux and react-router and their rather-central roles to the React eco-system. But first let's keep diving into React.</p>
<p>Rather our toys we've made so far to demonstrate how to make React components, let's actually start building our web app. We are going to make our home page. The home page is going to have a sweet background image, our logo, a text input to search for a specific show, and another button to just browse all videos.</p>
<p>I have predone most of the CSS for you for this particular course for you. Later in the course we're actually going to explore using styled-components but for now let's just import the CSS I wrote for you and tackle styled-components later. Follow the structure of the HTML and class names and you'll be golden. If at any time your styles look broken as compared to mine, chances are you misnamed a class or misstructured the tags.</p>
<p>We are going to add a link tag to our HTML. Typically you wouldn't have both external CSS <em>and</em> styled-components but believe me I'm going to save you a bunch of typing by limiting how much CSS I'm going to have you write. This is not a CSS course, haha.</p>
<p>Add this to index.html: <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/public/style.css&quot; /&gt;</code>. From here on out we'll have to use a webserver or else you'll have to mess with the paths to get the CSS to display correctly.</p>
<p>Let's start building our app. You can delete MyTitle.jsx if you desire; you can also leave it. We're not going to be using it any further. Go ahead and clear out most ClientApp.jsx and let's start putting our new app in here.</p>
<p>Oh, and you also have to name your video service. I named mine svideo but name your app whatever you want!</p>
<p>Right now it's going to be pretty simple. Drop in this:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { render } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"landing"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>svideo<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Search"</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>or Browse All<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
);

render(<span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.getElementById('app'));
</span></code></pre>
<p>Just in case you're not familiar, notice that we have no curly braces and only parens around our JSX. This means there's an implicit return and it's required by the Airbnb rules. If this is confusing for you, I recommend the <a href="http://2ality.com/2012/04/arrow-functions.html">2ality post on it</a>.</p>
<p>Save and run <code>npm run build</code>. If you followed the CSS naming and HTML structure, you should see a nice looking landing page. Also a good time to make sure if your code is still lint-compliant.</p>
<p>So, another tooling detour here: I'm getting pretty sick of having to hit the terminal every single time to see run build. Furthermore, build for webpack is pretty slow despite how small our code is. So let's take advantage of webpack's watch feature. This will watch for every time you save rebuild automatically. Additionally it will keep the unchanged bits (like the React library) in memory so it doesn't have to rebuild it every time. Try running <code>webpack --watch</code> in your terminal. It will use the same config we already made. See how much faster it is after running? Let's add a new npm script.</p>
<pre><code class="language-json">// in package.json in scripts
"watch": "webpack --watch",
</code></pre>
<p>Great, right? So, another part that's been bothering me is that it's such a pain to have to re-run ESLint every time. Either that or you'll get a bunch of errors all at once when you run it before you commit. Luckily we can have Webpack run ESLint each time it compiles. It will then notify you when you have errors.</p>
<p>Just like we're using the babel-loader to transpile our code, we're going to use the eslint-loader to run our linting for us. eslint-loader is similar to babel-loader, except it won't change our code: just warn us of linting errors.</p>
<p>Let's change our webpack config to use our new eslint-loader. eslint will automatically use our .eslintrc.json, regardless is called via the CLI or programmatically via webpack.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// inside rules, before babel-loader</span>
{
  <span class="hljs-attr">enforce</span>: <span class="hljs-string">"pre"</span>,
  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
  <span class="hljs-attr">loader</span>: <span class="hljs-string">"eslint-loader"</span>,
  <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>
}
</code></pre>
<p>If you were already running <code>yarn watch</code>, stop and start it again.</p>
<p>Nice! Any time you save now using <code>yarn watch</code> it will both compile your code <em>and</em> lint it. Pretty slick. And it all runs so much faster. We're going to get to how to make your code reloads <em>even faster</em>. We do the <code>enforce: pre</code> part to make sure that the lint part is loaded before the build step, ensuring our uncompiled code (and not the intermediary) is always the one being linted.</p>
<p>Now let's switch to the Webpack dev server which makes things just that much easier. The Webpack dev server speeds up development by letting you run a local server and serve all your content from the dev server. It watches and keeps everything in memory so rebuilds go faster. Add the following to your server to get it to serve your statics correctly:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// add as a top level config item</span>
devServer: {
  <span class="hljs-attr">publicPath</span>: <span class="hljs-string">'/public/'</span>
},
</code></pre>
<p>Now try running this from the directory of your project: <code>./node_modules/webpack-dev-server/bin/webpack-dev-server.js</code>. You could install this globally but we'll use npm's cli to make this easy. You should see in your CLI a bunch output from the build and probably some linter errors. Feel free to fix your errors but now you should be able to go <code>http://localhost:8080</code> to see your project running. You should also see the build output in the console of the browser. Cool! Add the following line to your npm scripts: <code>&quot;dev&quot;: &quot;webpack-dev-server&quot;,</code>. Now you can do <code>yarn dev</code> and your code will start building and serving right away!</p>
<p>But first let's keep going with our app. Our landing is pretty much done for now. We want to start working on the browse all page, but we need to move onto the router to do that real quick.</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>So now we have a basic landing page and we want to be able to transition to another page. Because we making this as a single page app, we are going to use the marvelous <a href="https://reacttraining.com/react-router/">react-router</a>. react-router is a robust piece of technology and we are just going to be scratching the surface of it now. If you intend on making a single page app, I suggest you deep dive into it to uncover all of its potential. It also now works for React Native.</p>
<p>We're going to be using React Router version 4 here. This is significant because React Router has gone through several thrashes of API, from 0 to 1, from 1 to 2/3, and now from 2/3 to 4. The authors have assured us that this is the last major thrash but it quite a departure, but thankfully the thrash is worth it. It got a lot easier to use.</p>
<p>We are just use the top level router at the moment. First, let's move our landing page into its own component so we can use ClientApp as the entry point for the app. Move all the code (except the ReactDOM last line; leave that there) to Landing.jsx.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// Landing.jsx</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> Landing = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"landing"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>svideo<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Search"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>or Browse All<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
);

export default Landing;
</span></code></pre>
<pre><code class="language-javascript"><span class="hljs-comment">// ClientApp.jsx</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { render } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> { HashRouter, Route } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;
<span class="hljs-keyword">import</span> Landing <span class="hljs-keyword">from</span> <span class="hljs-string">'./Landing'</span>;

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">HashRouter</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"app"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{Landing}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">HashRouter</span>&gt;</span>
);

render(<span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.getElementById('app'));
</span></code></pre>
<p>Cool. Make sure ESLint isn't yelling at you and that your app still works. It should appear pretty much the same to you. The HashRouter is a sort of hacky router which puts your route information into the hash of the URL (after the #). We'll use BrowserRouter later so we have nice URLs, but for now this gets us started. The Route component is a matched route; when it matchs the path provided (in this case we don't want fuzzy matching, hence the exactly attribute) it render the component provided, in this case the Landing component. It's wrapped in a div because routers can only have one child since they render them directly, but it's nice because all routes will now get the styling from the .app class for free.</p>
<p>Now we have a router so we're free to introduce a second page! Let's make our search page. Create a new file called Search.js. In Search.js put:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> Search = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &lt;h1&gt;Search!!<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Search;
</code></pre>
<p>Put in ClientApp</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { render } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> { HashRouter, Route } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;
<span class="hljs-keyword">import</span> Landing <span class="hljs-keyword">from</span> <span class="hljs-string">'./Landing'</span>;
<span class="hljs-keyword">import</span> Search <span class="hljs-keyword">from</span> <span class="hljs-string">'./Search'</span>;

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  &lt;HashRouter&gt;
    &lt;div className="app"&gt;
      &lt;Route exact path="/" component={Landing} /&gt;
      &lt;Route path="/search" component={Search} /&gt;
    &lt;/div&gt;
  &lt;/HashRouter&gt;
);

render(&lt;App /&gt;, document.getElementById('app'));
</code></pre>
<p>In Landing, change the <code>&lt;a&gt;or Browse All&lt;/a&gt;</code> to</p>
<pre><code class="language-javascript">// add at top with other requires
import { Link } from 'react-router-dom';

// change &lt;a&gt; to
&lt;Link to='/search'&gt;or Browse All&lt;/Link&gt;
</code></pre>
<p>Now you have another working route (which all it's doing is showing an h1) and a link to get there. When linking between routes with react-router, use the Link component. This allows you to refactor how routes work without having refactor all of your individual links (you could just make your a's href &quot;#/search&quot; and it would work for now but could break later.) Now your button should work to take you to the browser page and you should be able to use back and forward for free thanks to react-router.</p>
<p>The HashRouter sort of sucks though so let's migrate to BrowserRouter. First, we have to make webpack-dev-server aware that it should pass unfound routes back to index.html anyway. Add the following line your webpack.config.js inside of the devServer object: <code>historyApiFallback: true</code>. Once you do this, restart your Webpack dev server.</p>
<p>Then go to ClientApp.jsx and change all references (the import and the use of the component) of HashRouter to BrowserRouter. Now instead of #/search, it should go to just /search. Yay!</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>Let's start making our search page. We're going to start with some dummy data and work our way from there. Again, follow the same HTML structure and CSS naming as me and you'll get all the styling for free. Feel free to take a glance at ./data.json to see what's there. As you may have guessed, it's a bunch of Netflix shows. This whole workshop is actually just an elaborate advertisement for Netflix (just kidding; I promise.)</p>
<p>Webpack allows you to require in json files just like you would another JavaScript file so we'll take advantage of that when we start coding our new search page.</p>
<p>Previously Webpack required a JSON loader to load JSON files but now Webpack 2 allows it by default.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// in replace Search.js</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> preload <span class="hljs-keyword">from</span> <span class="hljs-string">'../data.json'</span>;

<span class="hljs-keyword">const</span> Search = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"search"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>{JSON.stringify(preload, null, 4)}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Search;
</code></pre>
<p>You should see it say dump a lot of JSON to the page at the top of the page. When you use curly braces in JSX, you're telling JSX you want it run a JavaScript expression and then display whatever it returns. If you take away those curly braces (try it) you'll see it literally displays &quot;JSON.stringify(preload, null, 4)&quot; as a string. So that's a neat tool to have; let's take it a step further and display all of the titles as their own components.</p>
<p>As you may remember, JSX is transpiling your JSX-HTML to function calls. As such, you may be able to imagine that a bunch of sibling components are just an array of components. Since they're just normal ol' JavaScript arrays, we can use some functional-programming-fu to transform data into components.</p>
<pre><code class="language-javascript">// replace render's return
&lt;div className='search'&gt;
  {preload.shows.map((show) =&gt; {
    return (
      &lt;h3&gt;{show.title}&lt;/h3&gt;
    )
  })}
&lt;/div&gt;
</code></pre>
<p>You should now see all of the titles in a nice scrollable list. This is the ng-repeat/#each of React: plain ol' JavaScript map. If you are not familiar with map, <a href="https://www.discovermeteor.com/blog/understanding-javascript-map/">read this</a>. This is one of the reasons I <em>love</em> React: for the most part best practices of React are just JavaScript best practices. There's very little DSL to learn. Cool! Let's flesh out how our search results are going to look.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> preload <span class="hljs-keyword">from</span> <span class="hljs-string">'../data.json'</span>;

<span class="hljs-keyword">const</span> Search = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"search"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {preload.shows.map(show =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"show-card"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">show.title</span>} <span class="hljs-attr">Show</span> <span class="hljs-attr">Poster</span>`} <span class="hljs-attr">src</span>=<span class="hljs-string">{</span>`/<span class="hljs-attr">public</span>/<span class="hljs-attr">img</span>/<span class="hljs-attr">posters</span>/${<span class="hljs-attr">show.poster</span>}`} /&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{show.title}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>({show.year})<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{show.description}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      ))}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
);

export default Search;
</span></code></pre>
<p>Try saving and re-rendering. You should see some nice cards for the shows. Notice that we can use those fancy curly braces to insert JavaScript expressions into HTML attribute too. Neat.</p>
<p>However we can reorganize this a bit better: the ShowCard component can be broken out into its own component. Let's do that. Make a file called ShowCard.jsx and put this in there:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> ShowCard = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"show-card"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">props.show.title</span>} <span class="hljs-attr">Show</span> <span class="hljs-attr">Poster</span>`} <span class="hljs-attr">src</span>=<span class="hljs-string">{</span>`/<span class="hljs-attr">public</span>/<span class="hljs-attr">img</span>/<span class="hljs-attr">posters</span>/${<span class="hljs-attr">props.show.poster</span>}`} /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{props.show.title}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>({props.show.year})<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{props.show.description}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
);

export default ShowCard;
</span></code></pre>
<p>Notice we're using the props object like we did for title and color before in MyTitle. This is what we are going to be receiving from our parents. In this case, an individual ShowCard needs to receive all the necessary data from its parent to be able to display it.</p>
<p>This is a good time to discuss the philosophy that's sort of tough to get used to with React coding. We typically think of user interfaces as entities that change over a span of actions and events. Think of a jQuery UI you have made. Imagine making a drop down. You would have to write the code for a user clicking it to opening the drop down to the user clicking an item in the drop down. It's a progression of time, events, and interactions. Imagine if there was a bug with that final interaction. You now have to work out in your head the sequence of events to get it to that same state that the bug occurs in to able to fix it. This is second nature to many of us since we have done it so many times.</p>
<p>React takes a fundamentally different approach but it takes some retraining of your brain. However I argue this approach is superior due to it being much easier to reason about, making it more readable for newcomers to the code and much more debuggable. In React, you think of your UI as snapshots. You do not think of it as a progression of time and events; rather, you look at the UI as how is it going to look given a set of parameters. That's all it is. Given a set of parameters, how does this UI look? Using the drop down example, you think of the drop down in its various states: an open state, a closed state, and an event that triggers when you click the item. You represent these varying states using props and state (we'll get to state in a bit.) Given a certain set of props, the UI always looks this way. This will become more concrete as we go on.</p>
<p>This brings me to my next point: when coding React, assume you have all the data you need coming in via props and then figure out later how to get it there. That will make it much easier. Just assume it all works and then later go make it work.</p>
<p>And these principles? Not invented by React. These are battle-tested ideas that stem a lot from functional programming. There's a lot of good computer science going on here, whether or not we use React to apply these concepts.</p>
<p>Okay, great, let's go to Search and drop in our new component.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> ShowCard <span class="hljs-keyword">from</span> <span class="hljs-string">'./ShowCard'</span>
<span class="hljs-keyword">import</span> preload <span class="hljs-keyword">from</span> <span class="hljs-string">'../public/data.json'</span>

<span class="hljs-keyword">const</span> Search = React.createClass({
  render () {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'search'</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
          {preload.shows.map((show) =&gt; {
            return (
              <span class="hljs-tag">&lt;<span class="hljs-name">ShowCard</span> <span class="hljs-attr">show</span>=<span class="hljs-string">{show}</span> /&gt;</span>
            )
          })}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    )
  }
})

export default Search
</span></code></pre>
<p>Much like you give an HTML tag an attribute is how you give props to children components in React. Here we're passing down an object to our child component to make it available to the ShowCard via props. Neat, right? Save it and reload the page. standard is going to give you a bunch of complaints but we're going to address that momentarily. You should see the same UI.</p>
<p>One of the errors you'll notice in the browser console is something like: &quot;Warning: Each child in an array or iterator should have a unique &quot;key&quot; prop. Check the render method of <code>Search</code>.&quot; You see this because we have multiple, similiar sibling components next to each other and React doesn't have a quick way to tell them apart. If you start reordering them (like if we added a sort feature) then React would just destroy and re-create them each time since it doesn't know you're just reordering them. This is unnecessarily expensive, as you may imagine, and can really kill your performance if you have a lot of complex nodes being created and destroyed. You can give React a shortcut to be able to tell them quickly apart: give each a component a unique identifier as a key attribute. So go add it to the ShowCard component like so: <code>&lt;ShowCard show={show} key={show.imdbID} /&gt;</code>.</p>
<p>So let's fix our lint errors now. Airbnb lint rules dictates that all props have a propType. React has a features that allows you to set propTypes which it then validates at runtime. This ends up being great for debugging because React now knows what type of props it should be getting so it can give you a meaningful error messages if there's a type mismatch or omission. So let's go fix the errors.</p>
<p>In ShowCard, go add this just below the declaration of the ShowCard function:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// add below import React</span>
<span class="hljs-keyword">import</span> { shape, string } <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>;

<span class="hljs-comment">// add below ShowCard function</span>
ShowCard.propTypes = {
  <span class="hljs-attr">show</span>: shape({
    <span class="hljs-attr">poster</span>: string.isRequired,
    <span class="hljs-attr">title</span>: string.isRequired,
    <span class="hljs-attr">year</span>: string.isRequired,
    <span class="hljs-attr">description</span>: string.isRequired
  }).isRequired
};
</code></pre>
<p>Now React knows to expect that show is both an object full of strings <em>and</em> those strings are required for the ShowCard to work. If a prop is optional (which is fine if it is indeed optional) then leave off the isRequired part. You must provide a default or the Airbnb rules are going to yell at you.</p>
<p>We can make this a little neater via the ES6/JSX spread operator. Let's try that. Change Search's ShowCard from <code>&lt;ShowCard show={show} /&gt;</code> to <code>&lt;ShowCard {...show} key={show.imdbID} /&gt;</code>. This will take all the properties from show and spread them out as individual properties on ShowCard. You <em>could</em> write <code>&lt;ShowCard title={show.title} poster={show.poster} description={show.description} year={show.year} /&gt;</code> but that's a lot of writing and this cuts an easy corner. Let's go modify ShowCard to match. This is a dangerous tool: only do it if you know every property in the object is needed in the component (or if you're doing a higher order component, but we'll get to the later.)</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { string } <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>;

<span class="hljs-keyword">const</span> ShowCard = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"show-card"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">props.title</span>} <span class="hljs-attr">Show</span> <span class="hljs-attr">Poster</span>`} <span class="hljs-attr">src</span>=<span class="hljs-string">{</span>`/<span class="hljs-attr">public</span>/<span class="hljs-attr">img</span>/<span class="hljs-attr">posters</span>/${<span class="hljs-attr">props.poster</span>}`} /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{props.title}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>({props.year})<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{props.description}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
);

ShowCard.propTypes = {
  poster: string.isRequired,
  title: string.isRequired,
  year: string.isRequired,
  description: string.isRequired
};

export default ShowCard;
</span></code></pre>
<p>We've now made our code a bit cleaner since we don't have to props.show... ad nauseam. From here we're going to move beyond prop types: we're going to incorporate Flow types. Prop types were deprecated as being part of the main package as of 15.5 since it's extra weight if you don't need them. If you're using types (like Flow or TypeScript) then they're redundant. Let's keep going.</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>You can do normal CSS (as we have doing so far) but there's been a recent interest in CSS-in-JS. There are several great approaches to this but we're going to use styled-components. The advantage of this is similar to what we see of doing JSX/React over separated templates and controllers: we get to mush together concerns for single components. If we do use CSS-in-JS, it means everything for a single component lives in a single place: we don't have to worry about including the right style sheets for the right components. It means if you include a component on a page, you get the markup, behavior, and style, guaranteed.</p>
<p>Let's talk about why this may be less than ideal. We have decades of browsers optimizing how to download, parse, and apply external style sheets. This way has been well thought out. I'm not saying we can't figure out how to optimize this path too; we just haven't yet. It's slower. This might be important to the performance of your app; it might not. You're also doubling your parse cost: we have to parse it as JS first, and then as CSS the second time. I think there's more around the tooling here: we can have our cake and eat it too. This is a relatively nascent idea: we'll figure it out if it pans out to be a good idea.</p>
<p>So the approach that styled-components takes is using ES6 tagged template literals. If this is your first encounter with them, you're not alone! It's outside the scope of this class to explore what they can do in-depth but as is customary, here's the <a href="http://2ality.com/2016/11/computing-tag-functions.html">2ality article</a> on it. Suffice to say that tagged template literals is a peculiar way of invoking normal functions. In our case, we give a CSS string to a styled-component function, it does some processing based on that, and spits out a valid React component. We instead of using a {div,h1,img,input,span,etc.} use the React component. Whatever normal attributes you would have given to that HTML element, you give to the styled component and it works great! Let's style our ShowCard.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { string } <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>;
<span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">'styled-components'</span>;

<span class="hljs-keyword">const</span> Wrapper = styled.div<span class="hljs-string">`
  width: 32%;
  border: 2px solid #333;
  border-radius: 4px;
  margin-bottom: 25px;
  padding-right: 10px;
  overflow: hidden;
`</span>;

<span class="hljs-keyword">const</span> Image = styled.img<span class="hljs-string">`
  width: 46%;
  float: left;
  margin-right: 10px;
`</span>;

<span class="hljs-keyword">const</span> ShowCard = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Wrapper</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Image</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">props.title</span>} <span class="hljs-attr">Show</span> <span class="hljs-attr">Poster</span>`} <span class="hljs-attr">src</span>=<span class="hljs-string">{</span>`/<span class="hljs-attr">public</span>/<span class="hljs-attr">img</span>/<span class="hljs-attr">posters</span>/${<span class="hljs-attr">props.poster</span>}`} /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{props.title}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>({props.year})<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{props.description}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Wrapper</span>&gt;</span>
);

ShowCard.propTypes = {
  poster: string.isRequired,
  title: string.isRequired,
  year: string.isRequired,
  description: string.isRequired
};

export default ShowCard;
</span></code></pre>
<p>Notice we created two different elements here: a div which we turned into Wrapper, and a img which we turned into Image. We associated some CSS with these two HTML elements and used them in our JSX. That's what styled-components are! You replace HTML elements with styled ones! Pretty cool, right? We won't do this for every component in our app since I want to focus more on the JS than I do on the CSS but I wanted to show you how to do it. It's fun to play with. If you were going to do some sort of CSS-in-JS solution, you'd probably want to be all-in on it.</p>
<p>We'll do some on the Details page but for now, let's go back to React-y stuff.</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>We've discussed props which all you to have immutable state passed from parents to children. However, as any seasoned UI developer will point out, user interfaces are inherently stateful. You app at some level must contain some level of mutability. React gives you a very controlled window to introduce this mutability to be able to reason easily about this mutability aptly called state.</p>
<p>While props are passed down from parents and are immutable, state is created, read, and mutated all <em>inside of</em> a component. In other words, if a component has state, that state cannot be mutated by a parent, child, or any other external influence; only that same component has access to the setState method which is the only way to mutate state. That component has the ability to expose methods to children that the child can call to let the parent know it should mutate its state, but again, it is totally up to the parent to respect that call and mutate the state; the child can only call methods exposed to it via passed-down props.</p>
<p>So let's see this in action. We're going to add a header that allows us to search our shows.</p>
<p>In Search.jsx, add the following:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// inside div.search, above and sibling to the div that contains the shows</span>
&lt;header&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>svideo<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
  &lt;input type=<span class="hljs-string">'text'</span> placeholder=<span class="hljs-string">'Search'</span> /&gt;
<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span>
</code></pre>
<p>Now the UI is in place. You should see a little header bar at the top. Let's start tracking what's actually in the input.</p>
<p>So far we've been using stateless functional components. These are amazing sicne they're the least complicated and therefore have the smallest surface area for bugs for you. But now we need to graduate to a full React class. There are two ways to accomplish this: ES6 classes and React.createClass. The React team has announced their intent to deprecate React.createClass and therefore we're teaching ES6 classes today. You can still use createClass: you just have include <a href="http://2ality.com/2015/02/es6-classes-final.html">another package</a>. But I suggest you use ES6 since that's the future.</p>
<p>ES6 classes have a lot to them and we're not going to really cover them super in-depth. If you need a more complete briefing on ES6 classes, <a href="http://2ality.com/2015/02/es6-classes-final.html">check 2ality</a>.</p>
<p>So our goal here is to track the contents of the input with React. We want React to be the source of truth of what's the search query is, not what lives in the DOM. This seems like splitting hairs but it's important. With data you always want one go-to place to get the truth: any time you try to synchronize two sources of truth, it's inevitably a never-ending font of bugs. Suffice to say: we want it to live in React and then have the DOM reflect that truth.</p>
<p>Before we do that, let's refactor to use a class instead of a stateless functional component.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> preload <span class="hljs-keyword">from</span> <span class="hljs-string">'../data.json'</span>;
<span class="hljs-keyword">import</span> ShowCard <span class="hljs-keyword">from</span> <span class="hljs-string">'./ShowCard'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Search</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> (
      &lt;div className="search"&gt;
        &lt;header&gt;
          &lt;h1&gt;svideo&lt;/h1&gt;
          &lt;input type="text" placeholder="Search" /&gt;
        &lt;/header&gt;
        &lt;div&gt;
          {preload.shows.map(show =&gt; &lt;ShowCard key={show.imdbID} {...show} /&gt;)}
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

export default Search;
</code></pre>
<p>Your ESLint will yell since this should be a stateless functional component: ignore it for now. But this is equivalent. Now that we've done that, let's add our statefulness.</p>
<pre><code class="language-javascript">  <span class="hljs-comment">// add to top of Search class</span>
  <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">super</span>(props);

    <span class="hljs-keyword">this</span>.state = {
      <span class="hljs-attr">searchTerm</span>: <span class="hljs-string">'this is a debug statement'</span>
    };
  }

<span class="hljs-comment">// replace header</span>
&lt;header&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{this.state.searchTerm}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
  &lt;input value={<span class="hljs-keyword">this</span>.state.searchTerm} type=<span class="hljs-string">"text"</span> placeholder=<span class="hljs-string">"Search"</span> /&gt;
<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span>
</code></pre>
<p>You'll see some errors/warnings in the console. Ignore for now.</p>
<p>I replaced the brand momentarily so you can see the see the searchTerm change. You should see whatever you made the initial state for searchTerm show up as the brand. Neat, right?</p>
<p>Now your input should have the initial state of your searchTerm. Now try and type and/or delete anything. You can't! You broke the Internet! Just kidding. But to understand why this weird bug is happening you have to understand how React handles keypresses. Your state object on your component states that the value of searchTerm is <code>'this is the default searchTerm'</code>. When a keypress happens, React kicks off a re-render. Since nothing modified the value of searchTerm, it's still the same string and thus it re-renders the same string there. Your state object is the source of truth. So let's make the value of searchTerm bound to the value of the input.</p>
<p>In other words, two data binding is not free in React. This is an advantage because it makes React less magical and thus easier to understand. A lesser imporant facet is that it's also more performant.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// add to constructor</span>
<span class="hljs-keyword">this</span>.handleSearchTermChange = <span class="hljs-keyword">this</span>.handleSearchTermChange.bind(<span class="hljs-keyword">this</span>);

<span class="hljs-comment">// add method</span>
handleSearchTermChange (event) {
  <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">searchTerm</span>: event.target.value })
}

<span class="hljs-comment">// replace input</span>
&lt;input
  onChange={<span class="hljs-keyword">this</span>.handleSearchTermChange}
  value={<span class="hljs-keyword">this</span>.state.searchTerm}
  type=<span class="hljs-string">"text"</span>
  placeholder=<span class="hljs-string">"Search"</span>
/&gt;
</code></pre>
<p>Now try typing in the input. As you see, the title is now reflective of whatever you type in the search input. So let's chat about what we did here. We made an event listener that handles the change events that the input throws off when it has a keypress. That event listener accepts an event that's technically a React synthetic event but its API looks just like a normal DOM event. In the event listener, we call <code>this.setState</code>, a method that allows you to mutate the state and then lets React re-render. If you don't call setState and instead mutate <code>this.state</code> yourself, React isn't privy to the fact the fact that you're changing stuff and thus doesn't know to re-render. In other words, never modify <code>this.state</code> directly and always just use setState. setState works like <code>Object.assign</code> in that it will do a merge of your objects (it's a shallow merge and not a deep merge) so you're free to just modify the keys you need to.</p>
<p>One bit of weirdness is the binding of context in the constructor. Yeah, I don't like it either. Let's talk about why you need it. Inside of <code>handleSearchTerm</code> you call <code>this.setState</code>. What <code>this</code> is in that context is important: it must refere to the instance of the Search class. So what context are in event listeners called in? The answer is not that one you need! (It's undefined in this case.) So you need to ensure that <code>this</code> refers to that Search component. There are several ways to accomplish this:</p>
<ul>
<li>On the input component, we could put <code>onChange={() =&gt;this.handleSearchTermChange()}</code>. Since it's an arrow function, a new context won't be created and thus Search would be the context. This is bad because every time that render is called (which can vary from a lot to a whole 💩 ton) a new function is created. That <em>sucks</em> for performance. Bind is not a cheap function call (depending on which JS engine you're in.) So don't do it. I show you because I see it in projects sometimes so I wanted to show you what's going on.</li>
<li>We can do just what I showed you: bind it in the constructor. This is what I typically do.</li>
<li>You can use <code>create-react-class</code> (the package I referred to earlier.) This autobinds the context for you.</li>
<li>Use the <a href="https://babeljs.io/docs/plugins/transform-class-properties/">transform-class-properties</a> Babel transform. If I were doing a personal project I'd do this but probably not at my company. This leverages a stage 2 proposal of a feature to be added to JS: Public Class Fields. Instead of <code>handleSearchTermChange(event) { /* body */ }</code> you'd have <code>handleSearchTerm = () =&gt; { /* body * }</code>. I believe this feature will make the language, but until things reach stage 3 I'm uncomfortable adding it to a long-term-supported repo. Again, because it's an arrow function, the context will be correct.</li>
</ul>
<p>Let's go actually implement this using class properties. Since it's stage 2, it's may change but I extracted a promise from <a href="https://twitter.com/thejameskyle/status/854725850826063872"><em>THE</em> James Kyle</a> that he'd write a codemod (a JS tool that will autorefactor code for you) for any changes that occur. Keep an eye on that. Add plugins as a top level property to your <code>.babelrc</code>.</p>
<pre><code class="language-json">"plugins": [
  "babel-plugin-transform-class-properties"
],
</code></pre>
<p>Now go back to Search and let's use it.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// Search.jsx</span>
<span class="hljs-comment">// delete bind line in constructor</span>
handleSearchTermChange = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">searchTerm</span>: event.target.value });
}
</code></pre>
<p>We can also simplify our declaration of initial state too instead of having the clunky constructor. Delete the constructor method and put into the Search class:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// delete constructor</span>

<span class="hljs-comment">// add in Search class</span>
state = {
  <span class="hljs-attr">searchTerm</span>: <span class="hljs-string">''</span>
}
</code></pre>
<p>Now go back and make sure everything works. Voila!</p>
<p>So go back now and change the brand to the correct title.</p>
<p>Let's make the search actually <em>do</em> something now. Since now we have our state being tracked, let's use it do a real time search on our titles.</p>
<pre><code class="language-javascript">// replace div inside search which contains shows
&lt;div&gt;
  {preload.shows
    .filter(
      show =&gt;
        `${show.title} ${show.description}`.toUpperCase().indexOf(this.state.searchTerm.toUpperCase()) &gt;= 0
    )
    .map((show, index) =&gt; &lt;ShowCard {...show} key={show.imdbID} id={index} /&gt;)}
&lt;/div&gt;
</code></pre>
<p>This is a little clever but let's dissect the new filter line we added. We're looking at both the title and description lines to search on and using the indexOf method from strings to see if the searchTerm exists within the description or title. We use toUpperCase on both to make it case agnostic. And the filter method on arrays just filters out items in an array that the method returns false on. Now try typing in your searchBox. You should see it filter as you type. We could make this more efficient but I'll leave that to you in your own time.</p>
<p>If you're unfamiliar with filter, <a href="http://adripofjavascript.com/blog/drips/filtering-arrays-with-array-filter">check this out</a>. If you're unfamiliar with arrow functions, <a href="http://www.2ality.com/2012/04/arrow-functions.html">check this out</a>. If you're unfamiliar with indexOf, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">look here</a>. And finally, for template strings (the back ticks instead of the quotes for the strings) <a href="https://developers.google.com/web/updates/2015/01/ES6-Template-Strings">look here</a>.</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p><strong>Note</strong>: This is using Jest. If you want to see how to test React components using <a href="https://mochajs.org/">Mocha</a>, Chai, Sinon, and Enzyme, see the <a href="https://btholt.github.io/complete-intro-to-react-v1/">v1 version</a> of this workshop.</p>
<p>Now that we have something worth testing, let's test it. We're going to be using Facebook's Jest (v19.0.2) to do it since it has some neat features. Go ahead and add the following to your npm scripts: <code>&quot;test&quot;: &quot;jest&quot;</code>. Then go to your JS directory, create a folder called <code>__tests__</code> inside of js, and create a file called Search.spec.jsx. I like to make my tests live right along side the files they test but I'm okay putting them in another directory: up to you. In either case Jest is smart enough to autodiscover them if you make the extension *.spec.jsx (or *.test.jsx if you prefer that. Also .js is fine too, just not with Airbnb.) The <code>__tests__</code> convention is one Facebook uses and works well. Feel free to use your own sensibilities as nothing is really set in stone here.</p>
<p>In Search.spec.js, put:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> renderer <span class="hljs-keyword">from</span> <span class="hljs-string">'react-test-renderer'</span>;
<span class="hljs-keyword">import</span> Search <span class="hljs-keyword">from</span> <span class="hljs-string">'../Search'</span>;

test(<span class="hljs-string">'Search renders correctly'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> component = renderer.create(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Search</span> /&gt;</span>);
  let tree = component.toJSON();
  expect(tree).toMatchSnapshot();
});
</span></code></pre>
<p>Your linter is probably yelling at you by now. Add <code>&quot;jest&quot;: true,</code> to the env config object. This will ESLint to not warn on Jest's top global variables.</p>
<p>This is a snapshot test and it's a super cool new feature of Jest. Jest is going to render out the component you tell it to and dump the state of that to a file. It's basically a free unit test that the computer generates for you. If the markup changes in the future unexpectedly, your unit test will fail and you'll see why it failed.</p>
<p>So then you may ask, &quot;What happens if I update the component on purpose?&quot; Easy! You run the test again with the -u flag and it will write out new snapshots. Awesome! Also note you're supposed to commit snapshots to git.</p>
<p>Okay, so go the CLI and run <code>yarn test</code> You're going to get some error about import being a bad token; this is true since as of Node.js 7, V8 (the JS engine that power Node.js) still doesn't understand ES6 modules, but we still want to use them in dev so we need to do some special Babel transformations just for testing. Go to your .babelrc file and put this:</p>
<pre><code class="language-json">{
  "presets": [
    "react",
    ["env", {
      "targets": {
        "browsers": "last 2 versions"
      },
      "loose": true,
      "modules": false
    }]
  ],
  "env": {
    "test": {
      "plugins": ["transform-es2015-modules-commonjs"]
    }
  }
}
}
</code></pre>
<p>This will add the correct Babel transformation when you are the test environment. Now let's make it so the jest command is run in the test environment (since by default it won't). Go back and change your line in your npm scripts to be <code>&quot;test&quot;: &quot;NODE_ENV=test jest&quot;</code>. Now it will apply that extra transformation for you. Now try running npm t again and see what happens. If it still fails on the import token, run <code>yarn test -- --no-cache</code>. The double dash means you want to pass parameters to whatever npm is running, in this case jest, so the command you're actually running is <code>jest --no-cache</code>. That's a useful trick to know. Then Jest likes to cache Babel transformations for ones it's already done so that you don't have to do it every time; this greatly speeds up running tests but it also doesn't check to see if you updated your .babelrc. So here we need to tell it to do so.</p>
<p>So now that you have a passing test, try modifiying Search and running it again. It'll give you a git diff type output and you can see what changed. If it's what you expect, you just re-run the command with -u at the end, <code>yarn test -- -u</code>. Let's actually put that as an npm script so we don't have to remember that. Add <code>&quot;test:update&quot;: &quot;NODE_ENV=test jest -u&quot;</code> to your npm scripts in package.json.</p>
<p>Okay, so now we have a few problems with this test. First, if we modify ShowCard, it's going to fail this test, and I think that's a problem. As much as possible, we want a Search test to only fail if something in Search breaks, and we want ShowCard to fail if ShowCard breaks. Luckily we can do that with a tool called <a href="http://airbnb.io/enzyme/index.html">Enzyme</a> from Airbnb. I show you both so you can see the easiest, more official way of doing snapshot testing (with react-test-renderer) and perhaps the more common way with Enzyme. Also, react-test-renderer and Enzyme can't be imported into the same file and we need to use Enzyme for other tests later.</p>
<p>So modifiy your test to read:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { shallow } <span class="hljs-keyword">from</span> <span class="hljs-string">'enzyme'</span>;
<span class="hljs-keyword">import</span> Search <span class="hljs-keyword">from</span> <span class="hljs-string">'../Search'</span>;

test(<span class="hljs-string">'Search renders correctly'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> component = shallow(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Search</span> /&gt;</span>);
  expect(component).toMatchSnapshot();
});
</span></code></pre>
<p>This still won't quite work the way we want: Jest doesn't know how to correctly serialize Enzyme components for snapshots. However the Jest team knew this would happen and gave us the ability to give a custom serializer. Add this as a top level property to your package.json:</p>
<pre><code class="language-json">"jest": {
  "snapshotSerializers": ["jest-serializer-enzyme"]
},
</code></pre>
<p>Run <code>yarn test</code> and you can see the difference. Instead of rendering out all the individual shows, we're rendering stubs of ShowCard with the props going into each of them. This ends up being preferable since if ShowCard breaks, it won't break <em>this</em> test. Run <code>yarn test:update</code>. You should see it updated your snapshot and now you're good to keep going. Let's test that if we search on the Search component, it displays the correct amount of shows.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// add two imports</span>
<span class="hljs-keyword">import</span> ShowCard <span class="hljs-keyword">from</span> <span class="hljs-string">'../ShowCard'</span>;
<span class="hljs-keyword">import</span> preload <span class="hljs-keyword">from</span> <span class="hljs-string">'../../data.json'</span>;

<span class="hljs-comment">// add new test at the bottom</span>
test(<span class="hljs-string">'Search should render correct amount of shows'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> component = shallow(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Search</span> /&gt;</span>);
  expect(preload.shows.length).toEqual(component.find(ShowCard).length);
});
</span></code></pre>
<p>Enzyme gives us lots of useful features. In this case, we can use it to do jQuery-like selections from our app. We can actually ask it, &quot;How many times does it use this React component&quot;. Logically, based on how our app works, it should have a ShowCard for each item in the preload data, so that's what we've checked here. Let's take it a step further and see if it searches correctly.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// underneath the last test</span>
test(<span class="hljs-string">'Search should render correct amount of shows based on search'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> searchWord = <span class="hljs-string">'house'</span>;
  <span class="hljs-keyword">const</span> component = shallow(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Search</span> /&gt;</span>);
  component.find('input').simulate('change',{target:{value: searchWord}});
  const showCount = preload.shows.filter((show) =&gt; `${show.title.toUpperCase()} ${show.description.toUpperCase()}`.includes(searchWord.toUpperCase())).length;
  expect(showCount).toEqual(component.find(ShowCard).length);
});
</span></code></pre>
<p>Here we're making sure that the UI displays the correct amount of ShowCards for how many shows it should match. If I were to take this a bit further, I would extract that filter function to a module, test that, and then import that same function into the production environment and the test environment. Here we're duplicating logic which isn't the best idea.</p>
<p>We're using Enzyme's simulate function which simulate's an event on the UI. Do note that as of present, this does <em>not</em> simulate event bubbling: you need to trigger the event on the same element that has the listener. We're making sure that if we type into the search that it filters properly. Keep in mind the way it works is if you call <code>.simulate('click', event)</code> it's actually directly calling the <code>onClick</code> handler directly and not going through an event system.</p>
<p>Enzyme has two other &quot;depths&quot; of rendering besides shallow: full DOM rendering and static page rendering. Full DOM uses <a href="https://github.com/tmpvar/jsdom">jsdom</a> to put the React app into a DOM-like environment if you need to interact with the DOM APIs. Unless you really need this, avoid it. It's <em>much</em> slower than shallow rendering because jsdom takes a long time to bootstrap and run. You can also do static rendering which uses <a href="https://cheerio.js.org/">Cheerio</a> to parse and interact with the resulting to HTML with a jQuery like environment. Again, I'd avoid this as it is much slower but if you need to do static analysis on the HTML, static rendering is the best way.</p>
<p>And now you get to hear my, Brian Holt's, opinion on unit testing in React: I don't much. This is an unpopular opinion so please evaluate your own decision here. Because my markup changes so frequently as I seek to make the best user experience I can, tests are outdated as soon as they're finished. Thus testing markup is counterproductive because they're constantly failing and out-of-date. Rather, what I do is I extract important pieces of generally-useful pieces of logic and unit test the hell out of those. That way as my markup thrashes and changes, I can still re-use battle-tested pieces of logic to power the UI.</p>
<p>That being said, snapshot testing is <em>so</em> easy and <em>so</em> fast to update, it seems to be worth it to me. I see open source projects using it to great effectiveness and it would be something I would integrate now if I was going to start a new project.</p>
<p>Snapshots can be used for more than just React components. I've seen them used for server responses and even <a href="https://github.com/prettier/prettier/tree/master/tests">Prettier</a> uses them to test output for their tests. Really anything that has deterministic output and can be serialized can be the target of a snapshot test.</p>
<p>At this point you can go create tests for the other components but you've been taught how and you can go do so yourself. We'll move on.</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>A good-but-not-great metric of how well you're testing your is code coverage. Basically it's how much of your code gets covered by your tests. There exist many tools to do this but we're going to use the most common in the JavaScript world: <a href="https://github.com/gotwarlost/istanbul">istanbul</a>.</p>
<p>What istanbul is going to do? Istanbul instruments your code to see what code gets run and then lets you when your tests are covering and/or not covering other parts. Run <code>npm test -- --coverage</code>.</p>
<p>So let's implement that as an npm script. Add:</p>
<pre><code class="language-json">"test:coverage": "NODE_ENV=test jest --coverage"
</code></pre>
<p>Now if you run <code>npm run cover</code> you should see 100% coverage on Search and and 80% ShowCard. That means all the exported code is getting covered in a test for Search and only 4/5 of it is for ShowCard. Yay! But where are the rest of our files? Well, we're not testing them at all yet so istanbul doesn't know about them. Once you start testing those files they'll show up.</p>
<p>Now go to the directory of your project and open in your browser coverage/lcov/index.html. This will let explore your project and see what's being covered in our project. If you look at ShowCard, you'll see that we're not covering the render method which makes sense since shallow rendering stubs ShowCard and doesn't let it render. What this means to you, at the very least, is that outside of the render method there's no runtime error but inside of it there may be. We should add a test to test render but that's for another time!</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>So webpack has a nifty ability to do what's called hot module reload (HMR.) If you've ever used LiveReload's CSS injection, this will sound familiar. HMR will take your code, compile it on the fly, and then inject it into your live-running code. Pretty cool tech.</p>
<p>If you're working a dropdown that requires three different clicks to get there, it's pretty neat to be able to change the code and watch the UI change without having to reload and get the UI back into a state where you can see the effects of your change.</p>
<p>While this is not exclusive to React, the React component architecture lends itself very well to hot module reload. Dan Abramov, creator of Redux, React Drag-and-Drop, and other great stuff also wrote the code for this. He's a magician.</p>
<p>How does it work? Seems magical. Well, since we're using ES6 modules, it means the dependency graph of our app is static. Think of it as a big tree with branches. If one branch changes, it means we can tear off the branch (the old code) and graft on a new one (the new code that Webpack just compiled) without stopping the rest of the code from running</p>
<pre><code>    Landing
   /
<span class="hljs-keyword">App</span>
   \
    <span class="hljs-keyword">Search</span> — ShowCard
</code></pre>
<p>That's our app as it stands in terms of dependencies. App imports Search which imports ShowCard. If Landing changes, we can leave App, Search, and ShowCard running as is and just graft on a new Landing. If Search changes, we have to graft on a whole new Search which includes new ShowCards.</p>
<p>This is accomplished with some black magic from Webpack and Babel. Babel when it transforms your code from JSX to JS and from ES6+ to ES5 will also instrument your modules with the ability to be replaced. We'll then insert a small client into our code that will receive small JSON packages via websockets and insert those into our running code. None of these details are important: mostly it's just for your information. react-hot-loader, Webpack, and Babel largely abstract these away from you.</p>
<p>Let's start with your .babelrc file. Add this as a top level property:</p>
<pre><code class="language-json">"plugins": [
  "react-hot-loader/babel"
],
</code></pre>
<p>This is what instruments the code with the ability to be replaced. Refactor your webpack.config.js to look like this:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>);

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">context</span>: __dirname,
  <span class="hljs-attr">entry</span>: [
    <span class="hljs-string">'react-hot-loader/patch'</span>,
    <span class="hljs-string">'webpack-dev-server/client?http://localhost:8080'</span>,
    <span class="hljs-string">'webpack/hot/only-dev-server'</span>,
    <span class="hljs-string">'./js/ClientApp.jsx'</span>
  ],
  <span class="hljs-attr">devtool</span>: <span class="hljs-string">'cheap-eval-source-map'</span>,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.resolve(__dirname, <span class="hljs-string">'public'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>,
    <span class="hljs-attr">publicPath</span>: <span class="hljs-string">'/public/'</span>
  },
  <span class="hljs-attr">devServer</span>: {
    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">publicPath</span>: <span class="hljs-string">'/public/'</span>,
    <span class="hljs-attr">historyApiFallback</span>: <span class="hljs-literal">true</span>
  },
  <span class="hljs-attr">resolve</span>: {
    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">'.js'</span>, <span class="hljs-string">'.jsx'</span>, <span class="hljs-string">'.json'</span>]
  },
  <span class="hljs-attr">stats</span>: {
    <span class="hljs-attr">colors</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">reasons</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">chunks</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="hljs-keyword">new</span> webpack.NamedModulesPlugin()],
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">enforce</span>: <span class="hljs-string">'pre'</span>,
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.jsx?$/</span>,
        <span class="hljs-attr">loader</span>: <span class="hljs-string">'eslint-loader'</span>,
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.jsx?$/</span>,
        <span class="hljs-attr">loader</span>: <span class="hljs-string">'babel-loader'</span>
      }
    ]
  }
};
</code></pre>
<ul>
<li>We required Webpack. We need to pull some plugins off of it.</li>
<li>We added some additional files to be packed into app via the entry property. The order here <em>is</em> important.</li>
<li>We gave the output a publicPath so it can know where the bundle.js file is since that's where it'll pull new bundles.</li>
<li>We told the dev server to run in hot reload mode.</li>
<li>We gave Webpack two plugins to work with. These affect the internals of Webpack. The second one is optional but it's helpful because it'll print the name of the files being hot reloaded.</li>
</ul>
<p>From here we need to split the App component out of ClientApp. We need to give hot module reload the ability to split the root component away from what actually renders the component to the page. Turns out we would have had to do this anyway for server-side rendering anyway so it's fine for us to tackle this now.</p>
<p>Create a new file called App.jsx and put this in there:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { BrowserRouter, Route } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;
<span class="hljs-keyword">import</span> Landing <span class="hljs-keyword">from</span> <span class="hljs-string">'./Landing'</span>;
<span class="hljs-keyword">import</span> Search <span class="hljs-keyword">from</span> <span class="hljs-string">'./Search'</span>;

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  &lt;BrowserRouter&gt;
    &lt;div className="app"&gt;
      &lt;Route exact path="/" component={Landing} /&gt;
      &lt;Route path="/search" component={Search} /&gt;
    &lt;/div&gt;
  &lt;/BrowserRouter&gt;
);

export default App;
</code></pre>
<p>Then from here, make your ClientApp.jsx look like this:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { render } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>;

<span class="hljs-keyword">const</span> renderApp = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.getElementById('app'));
};
renderApp();

if (module.hot) {
  module.hot.accept('./App', () =&gt; {
    renderApp();
  });
}
</span></code></pre>
<p>The first thing I always here is &quot;Am I shipping that module.hot stuff down in prod!?&quot; Yes, you are, and no, it doesn't matter. It's an if statement that gets runs once. You'll be fine. If you're so worried, use something like <a href="https://github.com/Couto/groundskeeper">groundskeeper</a>.</p>
<p>Okay, so we made renderApp a function so that we can render the App each time App itself changes. The rest of the modules will take care of themselves: this is all you need to hook up to get hot module reload to work! Also, when you build for production, all of the hot module reload code and transformations will be stripped out, meaning you're not making your package any larger (other than the if statement in ClientApp). Go give it a shot! Open your console (so you can see the debug statements) and go change something in your app. You should see the UI change without a full page reload. Pretty cool!</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>Welcome to the wild and mystical world of types in JavaScript. Types seem intimidating to many people but with a few basic concepts under our belt we can take advantage of 80% of the benefits. In other words, most of the beneftis of a type checker come from doing the most basic things. You can next-level crazy with types (see <a href="https://www.haskell.org/">Haskell</a> and <a href="https://www.idris-lang.org/">Idris</a>) but here we're just, you know, going with the flow.</p>
<p>So what is a type? JavaScript has a few basic types that it uses: Number, String, Object, Array, Function, and a few others. Because an item is a String, there's certain things you know about it: you can always call <code>substr</code> on a String and it won't cause an error. However, if you try to call <code>substr</code> on a Number, you're going to get an error. At the most basic level, that's what a type checker like Flow is going to get for you. It's going to prevent those sorts of errors by informing you that you have a type mismatch.</p>
<p>What's magical about Flow is that most of this type checking is <em>free</em>. You don't have to do anything to get it. You don't have to declare the type! It just knows what type is should by how you initialize it. If I say <code>const x = 'string here'</code> it knows that x is a string; you don't need to tell it that. Only in certain situations do you need to inform Flow of the types.</p>
<p>So, let's get Flow into our code. First thing to do is run <code>yarn run flow -- init</code>. You can also install Flow globally and do that, but this is nice because it'll run flow from your dependencies. This will create a <code>.flowconfig</code> file for you which is often enough; often you don't need to customize that config at all. In my case today, styled-components is throwing errors that isn't useful so I'm going to add <code>&lt;PROJECT_ROOT&gt;/node_modules/styled-components/*</code> under <code>[ignore]</code>. Unlike ESLint, you do typically want to have Flow run on your dependencies to get those typings. However sometimes libraries ship broken types so you can just ignore them (like I did with styled-components.)</p>
<p>Luckily for us, there's <a href="https://github.com/flowtype/flow-typed/tree/master/definitions/npm">flow-typed</a>. flow-typed is a repo of pre-typed common libraries for you and styled-components has an entry in there. Just <code>yarn global add flow-typed</code> and then run <code>flow-typed install styled-components@1.4.6</code> (or whatever version you have.) This will create a flow-typed directory that Flow already knows how to read from. In fact, check out the various type available to you. You should be able to grab types for enzyme, jest, react-router and react-router-dom too. Flow already has typings for React and react-dom.</p>
<p>Now you should be able to do <code>yarn run flow</code>. This likely isn't going to give you any errors back because we haven't opted-in any of our files to be type checked. Let's opt in Search.jsx. Add the <a href="https://en.wikipedia.org/wiki/Directive_(programming)">pragma</a> <code>// @flow</code> to the top of Search.jsx. Now run <code>yarn run flow</code> again. You should see an error that <code>handleSearchTermChange</code> is not annotated. Since Flow doesn't know how <code>handleSearchTermChange</code> is going to be invoked and with what parameters, it requires you to tell it beforehand. We do this by doing a type annotation.</p>
<p>Since we're including the Babel preset for React, we actually already are getting the Flow plugin. If we hadn't included <code>babel-preset-react</code> We'd have to go include the Flow plugin to do annotations. But it's there already.</p>
<p>So change in Search.jsx:</p>
<pre><code class="language-javascript">handleSearchTermChange = <span class="hljs-function">(<span class="hljs-params">event: SyntheticKeyboardEvent &amp;  { target: HTMLInputElement }</span>) =&gt;</span> {
  <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">searchTerm</span>: event.target.value });
}
</code></pre>
<p>What we've done here is add a type for the incoming parameter: a synthethic (React) keyboard event. This type is already built into Flow so we don't have to do anything more with it. Specifically we're interested win the <code>target</code> portion of it, so we identify that as well (target can technically be things other than an HTML input element.) By doing this we're ensuring we'll be ensuring this method is used properly. Run <code>yarn run flow</code> again and you should see <code>No errors!</code>. Congrats!</p>
<p>We've also made it so <code>handleSearchTerm</code> <em>must</em> be called with a SyntheticKeyboardEvent item. If you try to invoke it without that being passed in, you'll fail when you run Flow. You can use <a href="https://flow.org/en/docs/types/maybe/">maybe types</a> to get around this.</p>
<p>What's cool is that despite not adding a lot, we actually opted in a lot of behind-the-scenes checking for free. For example, Flow is smart enough to know that <code>searchTerm</code> is a string based on the initial <code>state</code> we provide for the class. Go ahead and try and setState for searchTerm to be a number. Flow will now fail since it was expecting a string there. If you need to accommodate both numbers and strings, you can use what's called a <a href="https://flow.org/en/docs/types/unions/">union type</a>.</p>
<p>It also bears talking about [any types][any] as well. Any types are both horrible and wonderful. Bascially, anything you make an any type is opted out of type checking. This can be great if you're rapid prototyping something and you're not sure what the final API is going to look like and you don't want to be fiddling with types (however, I will say that fiddling with the types can yield great insights into what you're actually trying to do!) They can also be useful for migrating large codebases to Flow: make big things an any type until you can get around to typing that particular object. Anything that you import from npm that you don't have typings for will by default be an any type. Also note there are <a href="https://flow.org/en/docs/types/mixed/">mixed types</a> that are useful if you're not sure what sort of thing is being passed in. Use this when possible instead of an any type.</p>
<p>At this point it's useful to see if your editor has integration with Flow. Sublime's is lackluster but you can at least get it show you where you have Flow errors in real time (using the same SublimeLinter we used for ESLint.) If you're going to double-down on Flow, you may investigate <a href="https://nuclide.io/docs/languages/flow/">Nuclide</a>. It's a package for [Atom][atom] that integrates with all of Facebook's tooling like React, React Native, Hack, and Flow. For now I'll be using just the Sublime tools.</p>
<p>Let's go opt-in ShowCard.jsx too! Add the <code>// @flow</code> pragma to the top. Here we've added propTypes from the prop-types library and with Flow those no longer serve a purpose: these types are known at compile time and thus don't need to be checked <em>again</em> at run time. Thus let's modify ShowCard like so:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// delete prop-types import</span>

<span class="hljs-comment">// replace ShowCard</span>
<span class="hljs-keyword">const</span> ShowCard = (
  props: {
    <span class="hljs-attr">poster</span>: string,
    <span class="hljs-attr">title</span>: string,
    <span class="hljs-attr">year</span>: string,
    <span class="hljs-attr">description</span>: string
  }
) =&gt; (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Wrapper</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Image</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">props.title</span>} <span class="hljs-attr">Show</span> <span class="hljs-attr">Poster</span>`} <span class="hljs-attr">src</span>=<span class="hljs-string">{</span>`/<span class="hljs-attr">public</span>/<span class="hljs-attr">img</span>/<span class="hljs-attr">posters</span>/${<span class="hljs-attr">props.poster</span>}`} /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{props.title}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>({props.year})<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{props.description}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Wrapper</span>&gt;</span>
);
</span></code></pre>
<p>This is how you type functional components. Pretty cool, right? Now if you run Flow again you shouldn't see any issues. On a tangent, imagine showing that code to yourself pre-ES6. Doesn't even look like (old) JavaScript! But's powerful, expressive, and readable (in my opinion.)</p>
<p>You should be able to <code>// @flow</code> to the top of Landing and App and make no changes.</p>
<p>Add <code>// @flow</code> to the top of ClientApp.jsx. You'll start getting errors about module.hot which is a global variable given to you by Webpack. Right now (as of writing) flow-typed doesn't have types for Webpack's API but this can be a useful exercise in showing you how to define your own types. In your flow-typed folder, add a file called types.js (not in the npm directory.) Add the following:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// @flow</span>

declare <span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span>: {
  <span class="hljs-attr">hot</span>: {
    accept(path: string, <span class="hljs-attr">callback</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">void</span>): <span class="hljs-keyword">void</span>
  }
};
</code></pre>
<p>Here we've declared a global variable called module which is an object that has a method called accept. accept takes two parameters: a string called path and a function called callback which returns undefined. accept itself returns undefined. There are several things you can put into these type definition files but I'll let you explore that on your own time!</p>
<p>Now our whole project is typed! We'll continue using Flow for the rest of this project but by no means are types required for React or any sort of JavaScript. It is extremely useful to have; you'll see here as you write code it's very useful to have the instant feedback that something is wrong with your code; once you start getting that it's hard to go back. But yeah, again, this is just one tool you could use to write React. It's not required.</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>So now we want to add a third page: a page where we can watch the trailer. This is going to be an application of what we know already.</p>
<p>Create a new file in js/ called Details.jsx. In Details put:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> Details = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"details"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>lolhi<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Details;
</code></pre>
<p>In App.jsx, put your new route:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// require your new route</span>
<span class="hljs-keyword">import</span> Details <span class="hljs-keyword">from</span> <span class="hljs-string">'./Details'</span>

<span class="hljs-comment">// add as last route in the nested routes</span>
&lt;Match pattern=<span class="hljs-string">'/details/:id'</span> component={Details} /&gt;
</code></pre>
<p>Here we've added a URL parameter using the colon. Now as a prop to Details you'll get whatever :id was. So now try to manually change the anchor on your url to be <code>http://localhost:8080/#/details/1</code>. You should see your new component here.</p>
<p>If you see a blank page and a 404 error in your console, chances are you need to add a leading slash to your script and link tags in your index.html file for the paths, <code>&lt;&amp;NegativeMediumSpace;script src=&quot;/public/bundle.js&quot;&gt;&lt;/script&gt;</code> and <code>&lt;&amp;NegativeMediumSpace;link rel=&quot;stylesheet&quot; href=&quot;/public/style.css&quot; /&gt;</code>.</p>
<p>Let's show you a neat debugging tip I totally stole from <a href="https://twitter.com/ryanflorence">Ryan Florence</a>. replace that h1 with this:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// instead of the h1 in render</span>
<span class="hljs-string">``</span><span class="hljs-string">`javascript
const Details = props =&gt; (
  &lt;div className="details"&gt;
    &lt;pre&gt;
      &lt;code&gt;
        {JSON.stringify(props, null, 4)}
      &lt;/code&gt;
    &lt;/pre&gt;
  &lt;/div&gt;
);
</span></code></pre>
<p>This is a useful way to dump your params to the page to see what react-router is giving you. This is <strong>awesome</strong> for state too; it shows you in real time what your state looks like. We'll dig into React Tools here in a sec for even better debugging but for now let's keep trucking with our Details.jsx.</p>
<p>We're going to show all the details of a show on this page and be able to play the trailer. There's a <em>big</em> problem here that we don't have that data on this page though; it's available in the Search route. We <em>could</em> require in data.json here given that our data is available that way but that typically isn't the case: we typically get this data from the server. If that's the case, you don't want to make two AJAX requests to get the same data. In other words, we need to share this state between components. The way you do this is by pushing up the state to the highest common ancestor component. In this case, that'd be the router in App. So let's first refactor Search to still work while it pulls in that data from Search.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// in App.jsx</span>
<span class="hljs-comment">// another import</span>
<span class="hljs-keyword">import</span> preload <span class="hljs-keyword">from</span> <span class="hljs-string">'../data.json'</span>

<span class="hljs-comment">// modify the existing route</span>
&lt;Route path=<span class="hljs-string">"/search"</span> component={props =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Search</span> <span class="hljs-attr">shows</span>=<span class="hljs-string">{preload.shows}</span> {<span class="hljs-attr">...props</span>} /&gt;</span>} /&gt;
</span></code></pre>
<p>Now make Search use it</p>
<pre><code class="language-javascript"><span class="hljs-comment">// delete import preload from '../data.json'</span>

<span class="hljs-comment">// below imports, above class Search</span>

type Show = {
  <span class="hljs-attr">title</span>: string,
  <span class="hljs-attr">description</span>: string,
  <span class="hljs-attr">year</span>: string,
  <span class="hljs-attr">imdbID</span>: string,
  <span class="hljs-attr">poster</span>: string,
  <span class="hljs-attr">trailer</span>: string
};

<span class="hljs-comment">// add propTypes inside Search</span>
props: {
  <span class="hljs-attr">shows</span>: <span class="hljs-built_in">Array</span>&lt;Show&gt;
};

<span class="hljs-comment">// change the map call instead of {preload.shows</span>
{<span class="hljs-keyword">this</span>.props.route.shows
</code></pre>
<p>Cool. Now it should still work but Search no longer imports the data but merely receives it as props. Now we can share this data with Details. Notice that Search has a function instead of a React component, but if you think about it a function that returns markup <em>is</em> a React component, so this works. This allows us to pass in the shows as a parameter to Search. You'll see this pattern often with react-router v4.</p>
<p>You'll also notice we created a Show type to match our show data. This is called a <a href="https://flow.org/en/docs/types/aliases/">type alias</a> This is awesome because now we can refer to objects as Shows and get all the typing along with that. Our first use of it was specifying that the props passed down was going to be an array of Shows. The syntax with Array has to do with a concept called <a href="https://flow.org/en/docs/types/generics/">generic types</a> which you are welcome to read about but beyond the scope of this class. You can do really cool and clever things with types and it's worth a dive down the rabbit's hole.</p>
<p>This Show type is going to be used across multiple files so it's worth it to make it a project-wide type like we did with Webpack's module. Go add to the types.js file in flow-typed. Add <code>declare</code> before type so it says <code>declare type Show = { […]</code> so it's now a global. Remove it from Search.jsx. Everything should still work. It should look like this:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> type Show = {
  <span class="hljs-attr">title</span>: string,
  <span class="hljs-attr">description</span>: string,
  <span class="hljs-attr">year</span>: string,
  <span class="hljs-attr">imdbID</span>: string,
  <span class="hljs-attr">poster</span>: string,
  <span class="hljs-attr">trailer</span>: string
};
</code></pre>
<p>Do note with with Flow and ESLint integrations with editors, it can be slow to update. It can be frustrating when you think you fixed a problem and it hasn't resolved yet.</p>
<p>Now we're going to pass the correct show to the Details page. There's a bunch of ways to do this:</p>
<ul>
<li>We could pass all the shows and let Details select the correct show. This isn't great because Details is given an additional concern it doesn't need to have.</li>
<li>We could create a callback in App that it passes to Details that Details calls with the correct ID and ClientApp hands back the correct show. This is slightly better but it's an odd API for getting data. Ideally we just hand down props and not a callback, especially since this isn't async.</li>
<li>Or we could hook into react-router's ability to pass props down through stateless functions like we did with Search and just pass down the correct show. This is the best approach.</li>
</ul>
<p>Add the following to App:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// add at the imports at the top</span>
<span class="hljs-keyword">import</span> type { Match } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;

<span class="hljs-comment">// replace Details Match component</span>
&lt;Route
  path=<span class="hljs-string">"/details/:id"</span>
  component={(props: { <span class="hljs-attr">match</span>: Match }) =&gt; {
    <span class="hljs-keyword">const</span> selectedShow = preload.shows.find(<span class="hljs-function">(<span class="hljs-params">show: Show</span>) =&gt;</span> props.params.id === show.imdbID);
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Details</span> <span class="hljs-attr">show</span>=<span class="hljs-string">{selectedShow}</span> {<span class="hljs-attr">...props</span>} /&gt;</span>;
  }}
/&gt;
</span></code></pre>
<p>At the top we're importing types from types from the flow-typed file for react-router-dom. We'll use this type to refer to the match attribute of the props. This is how you import types if you need to in the future. In case it's apparent to you, this a Flow-specific feature; this import line of code gets stripped out by the Babel transform. In the code, we're finding the correct show and passing that to Search.</p>
<p>If you run flow, you'll notice we broke our tests. Here is yet another benefit of Flow: it'd be easy to forget how modifying the API for Search would break the tests. Flow is quick to get that. It derives that fact because we changed what props are being passed to Search. Clever!</p>
<p>This should put the correct show as one of the props that App passes down to Details. If you refresh the page, you should see it now. (You have to have a valid URL for a details page, like <code>&lt;your localhost&gt;/details/tt4574334</code>).</p>
<p>As an aside, I've found the <em>best</em> way to organize React method component is the following</p>
<ol>
<li>props / defaultProps/ props</li>
<li>constructor</li>
<li>Other lifecycle methods like componentDidUpdate (we'll talk about those in a sec)</li>
<li>Your methods you create (like assignShow)</li>
<li>render</li>
</ol>
<p>Makes it easier to find things when you look for them.</p>
<p>So let's actually display some cool stuff:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> Details = <span class="hljs-function">(<span class="hljs-params">props: { show: Show }</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { title, description, year, poster, trailer } = props.show;
  <span class="hljs-keyword">return</span> (
    &lt;div className="details"&gt;
      &lt;header&gt;
        &lt;h1&gt;svideo&lt;/h1&gt;
      &lt;/header&gt;
      &lt;section&gt;
        &lt;h1&gt;{title}&lt;/h1&gt;
        &lt;h2&gt;({year})&lt;/h2&gt;
        &lt;img src={`/public/img/posters/${poster}`} alt={`Poster for ${title}`} /&gt;
        &lt;p&gt;{description}&lt;/p&gt;
      &lt;/section&gt;
      &lt;div&gt;
        &lt;iframe
          src={`https://www.youtube-nocookie.com/embed/${trailer}?rel=0&amp;amp;controls=0&amp;amp;showinfo=0`}
          frameBorder="0"
          allowFullScreen
        /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

export default Details;
</code></pre>
<p>Now you should have some nice looking UI.</p>
<p>Well, now we have a header in two places. That's a <strong>strong</strong> indicator that you should make it's its own component. Let's abstract that in a component and use that in both places. Create a new file called Header.jsx and put this in there:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { Link } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;

<span class="hljs-keyword">const</span> Header = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span>&gt;</span>
        svideo
      <span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span>
);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Header;
</code></pre>
<p>We're even going to throw in a link back to the home page for fun. Now open Details.jsx and put:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// add to the top</span>
<span class="hljs-keyword">import</span> Header <span class="hljs-keyword">from</span> <span class="hljs-string">'./Header'</span>

<span class="hljs-comment">// replace &lt;header&gt;...&lt;/header&gt;</span>
&lt;Header /&gt;
</code></pre>
<p>Let's put a back button on the Header so you can get back to Search after you reach it.</p>
<pre><code class="language-javascript">// after the h1 inside .header
&lt;h2&gt;
  &lt;Link to='/search'&gt;
    Back
  &lt;/Link&gt;
&lt;/h2&gt;
</code></pre>
<p>So let's integrate this to Search. But it's not so simple since on Search we want the header to have a search input and on Details we want a back button. So let's see how to do that. In Header.jsx put:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { Link } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;

<span class="hljs-keyword">const</span> Header = <span class="hljs-function">(<span class="hljs-params">props: { showSearch?: boolean, handleSearchTermChange?: <span class="hljs-built_in">Function</span>, searchTerm?: string }</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> utilSpace;
  <span class="hljs-keyword">if</span> (props.showSearch) {
    utilSpace = (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Search"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{props.searchTerm}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{props.handleSearchTermChange}</span> /&gt;</span>
    );
  } else {
    utilSpace = (
      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"header-back"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/search"</span>&gt;</span>
          Back
        <span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    );
  }
  return (
    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span>&gt;</span>
          svideo
        <span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      {utilSpace}
    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
  );
};

Header.defaultProps = {
  showSearch: false,
  handleSearchTermChange: function noop() {},
  searchTerm: ''
};

export default Header;
</span></code></pre>
<p>In Search.jsx:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// add to requires</span>
<span class="hljs-keyword">import</span> Header <span class="hljs-keyword">from</span> <span class="hljs-string">'./Header'</span>;

<span class="hljs-comment">// replace &lt;header&gt;&lt;/header&gt;</span>
&lt;Header handleSearchTermChange={<span class="hljs-keyword">this</span>.handleSearchTermChange} showSearch searchTerm={<span class="hljs-keyword">this</span>.state.searchTerm} /&gt;
</code></pre>
<p>This is how you have a child component modify a parent's state: you pass down the callback and let it call the parent to let the parent modify the state. This also demonstrates how to conditionally show one component and not another.</p>
<p>Lastly let's make our show cards clickable.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">'styled-components'</span>;
<span class="hljs-keyword">import</span> { Link } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;

<span class="hljs-keyword">const</span> Wrapper = styled.div<span class="hljs-string">`
  width: 32%;
  border: 2px solid #333;
  border-radius: 4px;
  margin-bottom: 25px;
  padding-right: 10px;
  overflow: hidden;
`</span>;

<span class="hljs-keyword">const</span> Image = styled.img<span class="hljs-string">`
  width: 46%;
  float: left;
  margin-right: 10px;
`</span>;

<span class="hljs-keyword">const</span> ShowCard = (
  props: {
    <span class="hljs-attr">poster</span>: string,
    <span class="hljs-attr">title</span>: string,
    <span class="hljs-attr">year</span>: string,
    <span class="hljs-attr">description</span>: string,
    <span class="hljs-attr">imdbID</span>: string
  }
) =&gt; (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">{</span>`/<span class="hljs-attr">details</span>/${<span class="hljs-attr">props.imdbID</span>}`}&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Wrapper</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Image</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">props.title</span>} <span class="hljs-attr">Show</span> <span class="hljs-attr">Poster</span>`} <span class="hljs-attr">src</span>=<span class="hljs-string">{</span>`/<span class="hljs-attr">public</span>/<span class="hljs-attr">img</span>/<span class="hljs-attr">posters</span>/${<span class="hljs-attr">props.poster</span>}`} /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{props.title}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>({props.year})<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{props.description}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Wrapper</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>
);

export default ShowCard;
</span></code></pre>
<p>Oh 💩! We messed up our styles. The reason is that the way Link works is that it outputs an <code>&lt;a&gt;</code> tag. Luckily, we can even style that too! Try this:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// replace styled.div with styled(Link)</span>
<span class="hljs-keyword">const</span> Wrapper = styled(Link)<span class="hljs-string">`

// add two lines to Wrapper's CSS, otherwise you'll get blue text styles
text-decoration: none;
color: black;
</span></code></pre>
<p>Now each of the cards should be clickable through to the details page and styled correctly!</p>
<p>But now we've messed up Search's tests. If you remember, Enzyme's testing library only shallowly renders the components. Since we moved the Header logic from inside Search into Header, this is going to mess up the existing snapshot (which we can just fix easily) and we won't be able to directly interact with the input inside of Header without some additional code.</p>
<p>We also changed the contract of Search since it now requires the shows to passed in. Modify the three <code>&lt;Search /&gt;</code> to be <code>&lt;Search shows={preload.shows} /&gt;</code>.</p>
<p>First, run <code>yarn test:update</code> to fix your snapshot. Your third test will still fail but the first one will update.</p>
<p>Next, open Search.spec.jsx and add this:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// last import</span>
<span class="hljs-keyword">import</span> Header <span class="hljs-keyword">from</span> <span class="hljs-string">'../Header'</span>;

<span class="hljs-comment">// modify the simulation line</span>
component.find(Header).dive().find(<span class="hljs-string">'input'</span>).simulate(<span class="hljs-string">'change'</span>, { <span class="hljs-attr">target</span>: { <span class="hljs-attr">value</span>: searchWord } });
</code></pre>
<p>By finding and &quot;diving&quot; on the Header component, we're telling Enzyme to also render that Header so that we can interact with it. Run your tests again and now they should pass!</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>Due to the structuring of our app, we haven't had to use React lifecycle methods despite the fact they're fairly common to use and thus important to know. One of the most compelling reasons to use lifecycle methods is to do AJAX. Once a component gets mounted to the page then we want to be able request data from the server. First let's discuss the lifecycle of a React component.</p>
<ol>
<li><strong>constructor/getInitialState</strong> - This is where set up your components initial state. The former is for ES6 classes (which is what we've been doing) and the latter is for the React.createClass method (which is deprecated as of 15.5.)</li>
<li><strong>getDefaultProps</strong> - Often you want to give your components default props if the parent doesn't provide them. Have a button that you want to be able to be a variety of colors but want default to green? That's what you would put in here. In ES6 classes, this can just be static property that's an object of the default props.</li>
<li><strong>componentWillMount</strong> - This method runs right <em>before</em> the component gets mounted. This one is not too common to use, but you will want to use it any time you want to ensure code to run both in node and in the browser.</li>
<li><strong>componentDidMount</strong> - This method runs right <em>after</em> your component gets put into the DOM. This method <em>will not get run in node but will in the browser</em>. This makes it so your component can render first <em>then</em> you can go get the data you need. In your component you can throw up a loader if you need to. Also if you need to interact with the DOM (like if you were wrapping D3 or a jQuery plugin) this would be the place to do it.</li>
<li><strong>componentWillReceiveProps</strong> - This method runs every time the React component receives new/different props from the parent. If some of the state you keep in your component is derived from the parent props, this is where you would take care of that. What if you keep a list of actors in a movie as state that you request from an API? If your parent passes you a new movie, you need to react to that and get new actors for the new movie. This would be an example of where to use this method.</li>
<li><strong>shouldComponentUpdate</strong> - This method returns a boolean letting React know if it should re-render the component. This is for performance purposes. If you have a component that will <em>never</em> update (like a static logo or something) you can just return false here. Normally React is really fast at doing this diffs anyway so it's a good idea to only put in a shouldComponentUpdate method if it's actually a performance issue. Typically in the method body you would check the bare minimum of state that needs to have changed to warrant a re-render. We'll discuss this more in depth later.</li>
<li><strong>componentWillUnmount</strong> - This method runs right before the component is taken off the DOM. Most common thing to do here is get rid of external event listeners or other things you need to clean up.</li>
</ol>
<p>Cool! So let's make our Details page get the details from a server! First let's make a nice loading spinner. Make a new file called Spinner.jsx and put this in there:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// @flow</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> styled, { keyframes } <span class="hljs-keyword">from</span> <span class="hljs-string">'styled-components'</span>;

<span class="hljs-keyword">const</span> spin = keyframes<span class="hljs-string">`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`</span>;

<span class="hljs-keyword">const</span> Image = styled.img<span class="hljs-string">`
  animation: <span class="hljs-subst">${spin}</span> 4s infinite linear;
  background-image: url(/public/img/loading.png);
`</span>;

<span class="hljs-keyword">const</span> Spinner = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &lt;Image src=<span class="hljs-string">"/public/img/loading.png"</span> alt=<span class="hljs-string">"loading indicator"</span> /&gt;;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Spinner;
</code></pre>
<p>This is how you do keyframe animations with styled-components. It's really cool because you'll get scoped animation and not have to worry about some polluted global namespace.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// import in axios</span>
<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>

<span class="hljs-comment">// add propType inside show</span>
imdbID: string

<span class="hljs-comment">// add state and componentDidMount to Details</span>
 state = {
  <span class="hljs-attr">apiData</span>: { <span class="hljs-attr">imdbRating</span>: <span class="hljs-string">''</span> }
};
componentDidMount() {
  axios
    .get(<span class="hljs-string">`http://localhost:3000/<span class="hljs-subst">${<span class="hljs-keyword">this</span>.props.show.imdbID}</span>`</span>)
    .then(<span class="hljs-function">(<span class="hljs-params">response: { data: { rating: string } }</span>) =&gt;</span> {
      <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">apiData</span>: response.data });
    });
}

<span class="hljs-comment">// add to render before return</span>
<span class="hljs-keyword">let</span> rating;
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.apiData.rating) {
  rating = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{this.state.apiData.rating}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span>;
} <span class="hljs-keyword">else</span> {
  rating = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Spinner</span> /&gt;</span>;
}

// add between year and poster
{rating}
</span></code></pre>
<p>We used to use the open movie database to request ratings against but it went closed. Rather than make your signup, there's a tiny API server for you to run with <code>ratingsAPI.js</code>. Just run <code>node ratingsAPI.js</code> from the commandline and let it run in the background. Now you'll be able to make requests against it. Feel free to add a line to your scripts object in package.json: <code>&quot;api&quot;: &quot;node ratingsAPI.js&quot;</code> so you can just run <code>yarn api</code> to run the server.</p>
<p>We're requiring in <a href="https://github.com/mzabriskie/axios">axios</a> which is a great little promise-based AJAX client and using that to make requests to the our little API server to find the IMDB ratings. If you go to your pages now you'll notice that the rating is showing up a little after the page renders. As you can see, we did this componentDidMount so that the user could see UI before waiting on an AJAX request. Note that it won't get server-side rendered either because the server doesn't call componentDidMount.</p>
<p>That's it! That's all you need to need know about AJAX with React as well as the lifecycle methods!</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>So far we've been using pretty old school debugging technology: console.logs and just dumping stuff out to the DOM. There is an easier way! <a href="https://github.com/facebook/react-devtools">React Dev Tools</a>! Grab it here for <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">Chrome</a> and <a href="https://addons.mozilla.org/en-US/firefox/addon/react-devtools/">Firefox</a>. In <em>theory</em> you can get the Chrome version working on Microsoft Edge, but good luck. If you're not using Chrome or Firefox, you're out of luck for now. They're talking about doing a standalone app but we'll see when that finally surfaces. I'll be talking about the Firefox version because that's the one I know the best but this should apply to Chrome just as well.</p>
<p>Dev Tools allow you to explore the virtual DOM of React as if it was just a normal DOM tree. You can see what props and states are in each component and even modify the state of components. The virtual DOM explorer is by-far the most useful part of it.</p>
<p>Find the Dev Tools in Firefox by opening the dev tools and the last tab (along side Console, Sources, Network, etc.) should be React on your page. If you don't see it try restarting your browser. If you <em>still</em> don't see it, the tab won't show up if the extension can't detect React on the page. You may have a dated version of the dev tools. After that I'm not sure; it can be fickle sometimes.</p>
<p>Feel free to poke around a bit here to familiarize yourself with what the React Dev Tools can do. Here are a couple of tricks for you:</p>
<ul>
<li>If you right-click -&gt; Inspect Element on something and then click the React tab, it will take you straight to that element in the virtual DOM.</li>
<li>Select something in the virtual DOM in the React tab. Now go to the Console tab and type <code>$r</code>. It should be a reference to the element you have selected in the virtual DOM and you can manipulate it.</li>
<li>As a side note, you can do the above trick with the normal DOM explorer with <code>$0</code>, <code>$1</code>, <code>$2</code>, <code>$3</code>, and <code>$4</code> instead where 0 is the last one you selected, 1 is the penultimate, etc. This is true in both Chrome and Firefox</li>
<li>iframes and Chrome/Firefox extensions don't work with React Dev Tools as of writing.</li>
<li>react-router v4 has <em>a lot</em> of nesting.</li>
</ul>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>As you app continues to grow, sometimes slow code paths can start to emerge. React is pretty good about being performant under normal loads but even React has its limits. One of the ways this can manifest itself is how often components are running through the re-render process without actually changing anything. These are called wasted renders. Normally you don't have to actually to worry about this: React handles a lot of wasted re-renders without slowing down the app at all and you can spend your time building features instead. It's helpful to glance at your performance data every once in a while but don't dwell too much on it.</p>
<p>So, as it stands, our code actually does have a code path that we can optimize. So let's go explore how we discover the problem and ultimately fix it.</p>
<p>First, open ClientApp.jsx and add:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// before App import</span>
<span class="hljs-keyword">import</span> Perf <span class="hljs-keyword">from</span> <span class="hljs-string">'react-addons-perf'</span>;

<span class="hljs-comment">// after App import</span>
<span class="hljs-built_in">window</span>.Perf = Perf;
Perf.start();
</code></pre>
<p>This is temporary code. You do not want to ship this in production. We'll use this to profile our code, get the useful info out of it and then remove it since it'd just be dead bloat in production.</p>
<p>So what we've done is import the React perf tools which will automatically hook into your React instance and track wasted renders for you. We're just setting it on the global window object so we can manipulate it directly in the console.</p>
<p>Now open your browser, and navigate around you webpage a bunch. Visit all the various ShowCard components, visit the home route, enter some search terms, delete the terms, enter different ones, etc. You want to cause the UI to change in all the various ways that are possible so we can see the slow code paths.</p>
<p>After you've sufficiently prodded your app, open you console and enter: <code>Perf.stop()</code> followed by <code>Perf.printWasted()</code>. You see a console table of the various wasted renders sorted by how many milliseconds are being wasted. Based on this you can find hot code paths and see what you can do to fix tihs.</p>
<p>In our case, it jumps out that our ShowCard is the greatest offender here: it's a component that once rendered never changes. There's nothing dynamic about any individual ShowCard. Armed with this information, there's an easy optimization to make here: shouldComponentUpdate.</p>
<p>Open ShowCard.jsx. Right now it's a function component so we can't add a lifecycle method like shouldComponentUpdate so we'll have to convert it to a class. Change the component to be:</p>
<pre><code class="language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowCard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  shouldComponentUpdate() {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  props: {
    <span class="hljs-attr">poster</span>: string,
    <span class="hljs-attr">title</span>: string,
    <span class="hljs-attr">year</span>: string,
    <span class="hljs-attr">description</span>: string,
    <span class="hljs-attr">imdbID</span>: string,
  };
  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Wrapper</span> <span class="hljs-attr">to</span>=<span class="hljs-string">{</span>`/<span class="hljs-attr">details</span>/${<span class="hljs-attr">this.props.imdbID</span>}`}&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Image</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">this.props.title</span>} <span class="hljs-attr">Show</span> <span class="hljs-attr">Poster</span>`} <span class="hljs-attr">src</span>=<span class="hljs-string">{</span>`/<span class="hljs-attr">public</span>/<span class="hljs-attr">img</span>/<span class="hljs-attr">posters</span>/${<span class="hljs-attr">this.props.poster</span>}`} /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{this.props.title}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>({this.props.year})<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{this.props.description}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Wrapper</span>&gt;</span>
    );
  }
}
</span></code></pre>
<p>Now whenever React goes to see if an individual instance of a ShowCard has changed, it'll run this function instead of running the render function and diffing against the last run of the render function. As you may imagine, this will go a lot faster.</p>
<p>Let's talk about the mechanics of shouldComponentUpdate. Almost all of the times I personally have used it, it has been just what you've seen here: returing false to ensure a component that doesn't needs to update doesn't go through the diffing process. There is a more advanced use case where perhaps updates only rely on a few pieces of state, props, or anything else. Here in shouldComponentUpdate, you could check those and only re-render if those changed. See the <a href="https://facebook.github.io/react/docs/optimizing-performance.html#shouldcomponentupdate-in-action">React docs</a> for more info.</p>
<p>Go back and profile your App again with the perf tools. You'll notice that ShowCard has disappeared from it.</p>
<p>This is a powerful and potentially bug-causing tool for you. Fathom later that we had dynamic content to ShowCard. If you call setState, nothing will happen until you remove or modify that shouldComponentUpdate method. Many people once they learn about shouldComponentUpdate will put it everywhere: don't. You'll cause more issues than you'll solve trying to solve perf problems that don't exist. React is normally fast enough as-is.</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>The next thing we want to do with our app is make the front page's search work so that when you type in a search query and hit enter it will automatically have searched for that on the Search page. Right now you have all the necessary tools to do that via state. You could just push the query term up to the ClientApp level and then pass that down to the Search and you'd be done. And that's the way you <em>should</em> do it given how small our app is.</p>
<p>But when these demo apps all the fun is in over engineering it and that's precisely what we're going to do: we're going to add Redux. Redux is a <em>fantastic</em> tool and a cool blending of the ideas of Facebook's <a href="https://facebook.github.io/flux/">Flux</a> and the <a href="http://elm-lang.org/">Elm</a> architecture.</p>
<p>As a side-note, there are some super rad new tools out there like [Mobx][mobx] that you can check out, but we're sticking to Redux. Mobx is incredible but with more power comes more complexity. If you learn Redux then learn Mobx (and reactive programming) you'll really appreciate and/or fear the power that comes from Mobx.</p>
<p>So what is Redux? <a href="http://redux.js.org/index.html">Redux is a predictable state container for JavaScript apps.</a> The best part about it while the concept is at first hard, I'd argue it's also very simple and elegant. Redux is great because it will run both client and server side, it's easy to test, and easy to debug. While Redux does not <strong>not</strong> follow the Flux pattern, you can easily see the similarities and once you've done one the other isn't hard to adapt to.</p>
<p>With Redux you a single store which stores your entire app state in a single tree. This is not like Flux where you'll have many stores for many different parts of your app; all data lives in a single store. You cannot directly modify the tree of data stored in this tree by typical assignment (ie <code>tree.prop = 'foo'</code> doesn't work.) Rather, every time you want to modify the tree, you emit an <strong>action</strong>. Your action then kicks off what's called a <strong>reducer</strong>. A reducer is a special function that take a tree and parameter(s) and returns a new tree after applying whatever transformations it deems fit. The way it gets away with just one store is when you need more data you just add more branches to your data tree. Like React? You only have one tree of components and when you need more you just add more nodes (branches) to your components.</p>
<p>So let's do the most basic addition of Redux to our app and convert the Search to use Redux. Again, this is using a sledgehammer to solve a tiny nail problem: huge overkill.</p>
<p>Create a reducers.js, put this in there:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> DEFAULT_STATE = {
  <span class="hljs-attr">searchTerm</span>: <span class="hljs-string">''</span>,
};

<span class="hljs-keyword">const</span> rootReducer = <span class="hljs-function">(<span class="hljs-params">state = DEFAULT_STATE, action</span>) =&gt;</span> {
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> rootReducer;
</code></pre>
<p>Create a store.js and put this:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> DEFAULT_STATE = {
  <span class="hljs-attr">searchTerm</span>: <span class="hljs-string">''</span>,
};

<span class="hljs-keyword">const</span> rootReducer = <span class="hljs-function">(<span class="hljs-params">state = DEFAULT_STATE, action</span>) =&gt;</span> {
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> rootReducer;
</code></pre>
<p>This is about as bare bones as Redux gets: we boot strapped a Redux store with a single top-level reducer and exported that. One thing you're going to find with Redux is there's a long path to follow to follow how your state changes. A very predicatble and consistent path, but it's still way longer than it used to be when we were just dealing with React state. This will often not be worth it. Evaluate this yourself on a per-project basis.</p>
<p>So like we said, each store starts with one reducer: the root reducer. This root reducer in turn will dispatch to other reducers. A few keys to notice here:</p>
<ol>
<li>You must return the finished state each time.</li>
<li>You must handle action types you've never seen before (which why we have the default clause.)</li>
<li>You take in state, you copy it, and you return a new state. That's what any reducer does. If you return the same state, Redux thinks nothing happened and won't inform React of any changes.</li>
<li>You must have a default state.</li>
<li>Redux by itself has no way of dealing with async actions. You need to pull in another library like redux-thunk. We'll use that later.</li>
</ol>
<p>We haven't opted into Flow yet. We will. I want to show you what Redux is doing at its core before we get clever.</p>
<p>Okay make a new file called actions.js and put in there:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// @flow</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SET_SEARCH_TERM = <span class="hljs-string">'SET_SEARCH_TERM'</span>;
</code></pre>
<p>This is going to give you an eslint error for prefer defaults exports when there's only one export. Generally this is a good idea but we're going to be adding more exports here momentarily.</p>
<p>Create a file called actionCreators.js:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// @flow</span>
<span class="hljs-keyword">import</span> { SET_SEARCH_TERM } <span class="hljs-keyword">from</span> <span class="hljs-string">'./actions'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setSearchTerm</span>(<span class="hljs-params">searchTerm</span>) </span>{
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">type</span>: SET_SEARCH_TERM, <span class="hljs-attr">payload</span>: searchTerm };
}
</code></pre>
<p>You'll see the same ESLint export error. Ignore for now.</p>
<p>We're using the <a href="https://github.com/acdlite/flux-standard-action">flux standard action</a> shape of actions for our Redux actions. This isn't required. The idea here is that we all adhere to this standard, this actions can be easily ported amongst Redux, Flux, and other state management libraries with ease. In any case, it'll make working Flow easier, which is the real reason.</p>
<p>Now back to reducers.js:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// import at top</span>
<span class="hljs-keyword">import</span> { SET_SEARCH_TERM } <span class="hljs-keyword">from</span> <span class="hljs-string">'./actions'</span>;

<span class="hljs-comment">// new reducer above rootReducer</span>
<span class="hljs-keyword">const</span> setSearchTerm = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, state, {<span class="hljs-attr">searchTerm</span>: action.payload});
}

<span class="hljs-comment">// add new case before default inside rootReducer</span>
<span class="hljs-keyword">case</span> SET_SEARCH_TERM:
  <span class="hljs-keyword">return</span> setSearchTerm(state, action);
</code></pre>
<p>More files! This should be it for our simple project. Actions is just going to a bunch of exporting of constants. Why do we do this? The way Redux's root reducer decides to dispatch it to one of various reducers is by the action type. Thus it needs to match in both the action creator and the reducer. Rather than having magic strings, we have one central source of truth both file read from. Makes refactoring easy too.</p>
<p>I often get asked why we do make the actions strings and not <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">symbols</a>. While it does work, the dev tools are unable to serialize symbols and thus we makes it much harder to debug. Maybe some day. We'll look at the dev tools in a bit.</p>
<p>The actionCreator is what the UI is actually going to interact with to make changes to the Redux store. In other words, your UI never directly interacts with the store nor the reducers. It <em>only</em> interacts with action creators which then are handled in the reducers which then change the store which then inform the UI of the changes. One way data flow!</p>
<p>If you haven't seen the syntax <code>const x = { searchTerm }</code> it just means <code>const x = { searchTerm: searchTerm }</code>. It's just a shortcut.</p>
<p>The rootReducer uses the same SET_SEARCH_TERM constant to hinge in the rootReducer. Also note we return a new object every time when we make a new object. This lets Redux know to inform any subscribers (in this case your React app) that changes happened.</p>
<p>Okay, so let's go make landing interact with the store. But first we need to connect Redux to React via the react-redux package. Go to App.jsx.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// import react-redux and your new store</span>
<span class="hljs-keyword">import</span> { Provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;
<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span>;

<span class="hljs-comment">// wrap everything in router in provider</span>
render () {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span>&gt;</span>
        […]
      <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span></span>
  )
}
</code></pre>
<p>Provider connects React to Redux for you. Now you can magically use a connect function (also provided from react-redux) that allows you to pull in the pieces of state you need in each component. Let's got make Landing.jsx read and write to Redux.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { connect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;
<span class="hljs-keyword">import</span> { Link } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;

<span class="hljs-keyword">const</span> Landing = <span class="hljs-function">(<span class="hljs-params">props: { searchTerm: string }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"landing"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>svideo<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{props.searchTerm}</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Search"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/search"</span>&gt;</span>or Browse All<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
);

const mapStateToProps = state =&gt; ({
  searchTerm: state.searchTerm
});

export default connect(mapStateToProps)(Landing);
</span></code></pre>
<p>Connect is a function that allows your component to tap into the Redux store's state. The mapStateToProps allows you to select which pieces of state are passed into your component which helps keep thing clean. At the bottom we export a connected version of the component. Now if you reload the page the input doesn't work for the same reason it didn't with React previously: we are never sending the typed text to Redux to update its state. Let's do that now.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// at top</span>
<span class="hljs-keyword">import</span> { setSearchTerm } <span class="hljs-keyword">from</span> <span class="hljs-string">'./actionCreators'</span>

<span class="hljs-comment">// add type for function</span>
<span class="hljs-keyword">const</span> Landing = <span class="hljs-function">(<span class="hljs-params">props: { searchTerm: string, handleSearchTermChange: <span class="hljs-built_in">Function</span> }</span>) =&gt;</span> (

<span class="hljs-comment">// change input</span>
&lt;input onChange={props.handleSearchTermChange} value={props.searchTerm} type=<span class="hljs-string">"text"</span> placeholder=<span class="hljs-string">"Search"</span> /&gt;

<span class="hljs-comment">// at the bottom</span>
<span class="hljs-keyword">const</span> mapDispatchToProps = <span class="hljs-function">(<span class="hljs-params">dispatch: <span class="hljs-built_in">Function</span></span>) =&gt;</span> ({
  handleSearchTermChange(event) {
    dispatch(setSearchTerm(event.target.value));
  }
});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Landing);
</code></pre>
<p>We're import the action creator so that we can dispense well-formed actions to Redux. Technically you could form the action here inside of the dispatch function but it's a good idea to separate that logic so that it can be re-used and individually tested.</p>
<p>In addition to adding the state to the props via mapStateToProps, we also want to inject a function which can dispatch actions to your reducers. We do this via a mapDispatchToProps function which achieves a similar end.</p>
<p>At the end, make sure you add that to the connection function.</p>
<p>After this, we want to be able to send the user to the search page once they hit enter. We'll do this via interacting with react-router imperatively.</p>
<p>Since we'll be introducing some methods, we also should refactor this into ES6 class component. It'll make it easier to follow. We've outgrown the component function.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { connect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;
<span class="hljs-keyword">import</span> { Link } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;
<span class="hljs-keyword">import</span> type { RouterHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;
<span class="hljs-keyword">import</span> { object } <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>;
<span class="hljs-keyword">import</span> { setSearchTerm } <span class="hljs-keyword">from</span> <span class="hljs-string">'./actionCreators'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Landing</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">static</span> contextTypes = {
    <span class="hljs-attr">history</span>: object
  };
  props: {
    <span class="hljs-attr">searchTerm</span>: string,
    <span class="hljs-attr">handleSearchTermChange</span>: <span class="hljs-built_in">Function</span>,
    <span class="hljs-attr">history</span>: RouterHistory
  };
  goToSearch = <span class="hljs-function">(<span class="hljs-params">event: SyntheticEvent</span>) =&gt;</span> {
    event.preventDefault();
    <span class="hljs-keyword">this</span>.props.history.push(<span class="hljs-string">'/search'</span>);
  };
  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"landing"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>svideo<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{this.goToSearch}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
            <span class="hljs-attr">onChange</span>=<span class="hljs-string">{this.props.handleSearchTermChange}</span>
            <span class="hljs-attr">value</span>=<span class="hljs-string">{this.props.searchTerm}</span>
            <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
            <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Search"</span>
          /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/search"</span>&gt;</span>or Browse All<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    );
  }
}

const mapStateToProps = state =&gt; ({
  searchTerm: state.searchTerm
});

const mapDispatchToProps = (dispatch: Function) =&gt; ({
  handleSearchTermChange(event) {
    dispatch(setSearchTerm(event.target.value));
  }
});

export default connect(mapStateToProps, mapDispatchToProps)(Landing);
</span></code></pre>
<p>So we're introducing a new concept here from React: context. This is a dangerous tool and I will tell you I personally have never <em>put</em> anything on context. I've only consumed things from context that libraries like react-router and react-redux (which both do use context) put on there. Use at your own peril. It will cause more harm than solve.</p>
<p>Context is basically global state: anywhere inside a React app can read and write to state. If this sounds nightmarish to you then you have good sense: it defeats a lot of the benefits to React. However, with something like react-router it's very useful because the whole app does care about routing, as it does about Redux.</p>
<p>Notice the contextTypes are like propTypes. However, contextTypes are even more important to React than propTypes: if you don't have them the object you're looking for won't be there. In other words, you must identify in contextTypes the properties the component cares about or they will not be available on context. This ongoing debate on how this will work in the future since prop types have been removed from the React package itself.</p>
<p>Also note that contextTypes property is static. This is important so that React can read the types off the class instead of off the instance.</p>
<p>Okay, so now I want to show you a neat experimental feature: decorators. This is 1000% optional. What we have works and you are welcome to stick with it. I just think they're fun to use and make the code a bit nicer to read. Add the plugin <code>&quot;babel-plugin-transform-decorators-legacy&quot;</code> to your .babelrc <strong>before</strong> the class-properties one. The order is important.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// in Landing.jsx</span>

<span class="hljs-comment">// move mapStateToProps and mapStateToDispatch to above the class</span>

<span class="hljs-comment">// add above the class</span>
<span class="hljs-comment">// $FlowFixMe</span>
@connect(mapStateToProps, mapDispatchToProps)

<span class="hljs-comment">// change the export</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Landing;
</code></pre>
<p>Decorators are an amazing feature to augment functionality in a declarative fashion. The code you see here works precisely the same way the other code did, it's just a bit less dense (I'd say.) The <code>// $FlowFixMe</code> bit is so that Flow will ignore that line: it doesn't handle decorators yet so this suppresses that warning. The reason why the transform is considered &quot;legacy&quot; is because the proposal is a bit in flux, but in nearly any case this code won't have to change.</p>
<p>We're going to revert back to using the <code>connect(…)(…)</code> notation for now though. Because the Flow parser doesn't support decorators (and won't until it's more stable) we can't use it since Prettier relies on the Flow parser. It works with the Babylon parser but then we can't use Flow. Make your own tradeoff there. You could put the <code>// prettier-ignore</code> comment to make it ignore the line too.</p>
<p>Okay, so we're using a form to take care of when hits enter: this is good for accessibility and a good way to take care of submitting. Once a user hits enter, it calls goToSearch where we imperatively call the router to take us to search. This will preserve our Redux state; however Search.jsx is not yet reading from Redux. Let's go fix that.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { connect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;
<span class="hljs-keyword">import</span> ShowCard <span class="hljs-keyword">from</span> <span class="hljs-string">'./ShowCard'</span>;
<span class="hljs-keyword">import</span> Header <span class="hljs-keyword">from</span> <span class="hljs-string">'./Header'</span>;

<span class="hljs-keyword">const</span> Search = (props: {
  <span class="hljs-attr">searchTerm</span>: string, <span class="hljs-comment">// eslint-disable-line react/no-unused-prop-types</span>
  shows: <span class="hljs-built_in">Array</span>&lt;Show&gt;
}) =&gt; (
  &lt;div className="search"&gt;
    &lt;Header showSearch /&gt;
    &lt;div&gt;
      {props.shows
        .filter(show =&gt; `${show.title} ${show.description}`.toUpperCase().indexOf(props.searchTerm.toUpperCase()) &gt;= 0)
        .map((show, index) =&gt; &lt;ShowCard {...show} key={show.imdbID} id={index} /&gt;)}
    &lt;/div&gt;
  &lt;/div&gt;
);

const mapStateToProps = state =&gt; ({
  searchTerm: state.searchTerm
});

export default connect(mapStateToProps)(Search);
</code></pre>
<p>Notice we got to delete a lot of code. Always feels good! We're externalizing our state management so that'll happen more as well. Also notice that Search no longer cares about modifying searchTerm since it itself doesn't need to. This is cool; having concerns live where they happen is a really positive thing. Otherwise not much new here. This will work now if you go to Landing and submit a search term from there.</p>
<p>We do have to add that ESLint ignore since ESLint is not perfect. It wasn't able to track the props being used that deeply in the function. This a rare occurrence.</p>
<p>We broke the header. Let's go fix that.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// import at top</span>
<span class="hljs-keyword">import</span> { connect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>
<span class="hljs-keyword">import</span> { setSearchTerm } <span class="hljs-keyword">from</span> <span class="hljs-string">'./actionCreators'</span>

<span class="hljs-comment">// delete searchTerm and handleSearchTerm from defaultProps</span>

<span class="hljs-comment">// at the bottom</span>
<span class="hljs-keyword">const</span> mapStateToProps = <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> ({ <span class="hljs-attr">searchTerm</span>: state.searchTerm });
<span class="hljs-keyword">const</span> mapDispatchToProps = <span class="hljs-function">(<span class="hljs-params">dispatch: <span class="hljs-built_in">Function</span></span>) =&gt;</span> ({
  handleSearchTermChange(event) {
    dispatch(setSearchTerm(event.target.value));
  }
});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Header);
</code></pre>
<p>Since Header does care about modifying searchTerm we bring in that logic here. Otherwise not much changes!</p>
<p>Okay, so now we want to type Redux. This is no trivial feat but I promise that it will save you bugs. And in the process we'll learn more about Flow too.</p>
<p>Open your types.js file in the flow-typed directory and let's add some new types.</p>
<pre><code class="language-javascript">declare type ActionType = <span class="hljs-string">'SET_SEARCH_TERM'</span>;

declare type ActionT&lt;A: ActionType, P&gt; = {|
  type: A,
  <span class="hljs-attr">payload</span>: P
|};

<span class="hljs-keyword">export</span> type Action = ActionT&lt;<span class="hljs-string">'SET_SEARCH_TERM'</span>, string&gt;;
</code></pre>
<p>Here we're creating an enumerated typed: ActionType. This type is saying anything that's an ActionType can only be that string. Any other string (or anything else) causes an error. This will catch if you spell the action types wrong, which is nice. We'll add another action type later so you can see how to add more.</p>
<p>Below that, we're creating a generic action. It's saying the <code>type</code> (which we represent with A) will always an ActionType. It's then saying that there must be a payload type which is always going to exist. We can then define later what that type is going to be (which is what P represents.) We are not representing the full flux standard action here: it also accounts for metadata and errors, but we're keeping it simple here.</p>
<p>Lastly, with the Action (which is the one we export, the other two are only for use in this file) is creating the actual useable action types. We only have one: SET_SEARCH_TERM. It then defines what those that action's payloads must look like: a string. For every action we create, we'll have to come back here to define their types. This seems burdensome but it makes your Redux ironclad. The ongoing mantainability here makes it worth it, I promise.</p>
<p>Go back to reducers.js. We're going to refactor this a bit to make it play nicer with Flow as well as show you a cool way to write Redux: combineReducers.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">import</span> { combineReducers } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;
<span class="hljs-keyword">import</span> { SET_SEARCH_TERM } <span class="hljs-keyword">from</span> <span class="hljs-string">'./actions'</span>;

<span class="hljs-keyword">const</span> searchTerm = <span class="hljs-function">(<span class="hljs-params">state = <span class="hljs-string">''</span>, action: Action</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (action.type === SET_SEARCH_TERM) {
    <span class="hljs-keyword">return</span> action.payload;
  }
  <span class="hljs-keyword">return</span> state;
};


<span class="hljs-keyword">const</span> rootReducer = combineReducers({ searchTerm });

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> rootReducer;
</code></pre>
<p>combineReducers creates the root reducer for you. What's peculiar of how this works as opposed to writing our own is that it separates each reducer into its own silo. Before, when writing our own, each reducer got its own copy of the entire state tree and had to be careful to not overwrite anything else it didn't intend. With combineReducers, each reducer <em>only</em> gets the part that it's worried about and nothing else. So, because in the combineReducers object we called the key <code>searchTerm</code>, the searchTerm method will only be supplied that bit of the state tree and nothing else. Thus, inside each reducer we handle its default state (for searchTerm the default value is empty string) and also have to provide for if the reducer does not recognize the action type. This is less performant but unless you're firing off <em>a lot</em> of actions and/or have <em>a lot</em> (read: dozens/hundreds) of action types, it'll make zero difference overall.</p>
<p>So let's roll with this and move to making async actions now.</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>One of the most compelling reason to use redux is its amazing debugging experience. redux has the <em>fantastic</em> ability to do time-traveling debugging, meaning you can step forwards and backwards through actions you've dispatched. It's really powerful for debugging.</p>
<p>There are several ways to get it working but I'm going to show you the bare minimum to get up and running. Unlike React, there is some code you have to put in to get it working. Luckily, it's like two or three lines.</p>
<p>In Store.js put:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">import</span> { createStore, compose } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;
<span class="hljs-keyword">import</span> rootReducer <span class="hljs-keyword">from</span> <span class="hljs-string">'./reducers'</span>;

<span class="hljs-keyword">const</span> store = createStore(
  rootReducer,
  compose(
    <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span>.devToolsExtension !== <span class="hljs-string">'undefined'</span> ? <span class="hljs-built_in">window</span>.devToolsExtension() : <span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f
  )
);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;
</code></pre>
<p>That's it for code! It just adds a middleware to redux that hooks into the dev tools. It's also doing a window check to make sure if you're unit testing or running your components in node that the window reference doesn't blow up.</p>
<p>Now go grab the <a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en">Chrome extension</a> or <a href="https://addons.mozilla.org/en-US/firefox/addon/remotedev/">Firefox extension</a>. For Safari, Edge, and other browsers as well as React Native, there's a remote plugin way to achieve it. <a href="https://github.com/zalmoxisus/remote-redux-devtools">See here</a>. Good news is that you can actually just build the debugger into the page so it works everywhere. Bad news is I'm going to show you how since I've never done it. In any case, feel free to explore it on your time.</p>
<p>Okay, last bit: this doesn't work with the <code>file:///</code> protocol. But luckily we're using webpack-dev-server so it doesn't matter.</p>
<p>Now you should see three green circles with smaller orange circles circling the green ones on your Chrome or Firefox tool bar. Click on that and that should show you the redux tools. This allows you to play with the redux tools. I'll let you toy with them but suffice to say they're pretty impressive.</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>Redux by default has no mechanism for handling asynchronous actions. This means you either need handle everything async in your React (gross) or we have to augment Redux to handle async code. The former is really a non-starter: the point of Redux is centralize state manipulation and not having the ability to do async is just silly. We're building interfaces and interfaces are inherently asynchronous.</p>
<p>Okay, so we've decided to augment Redux. How do we do that? Well, luckily, Redux has the ability to have middlewares, just like your server can. What we can do is add a middleware that can handle more than just action objects. There are a myriad of popular ones but we're going with the most popular, the simplest, and the easiest: redux-thunk. I'll venture to say that if you build any Redux app, rarely are you not going to include redux-thunk, even if you include one of the other async Redux middlewares. It's frequently useful, even beyond it's async applications.</p>
<p>So let's unpack the word thunk: it's a weird computer science term that seems more difficult than it actually is. Imagine you need to write a line of code that calculates the conversion from USD to EUR. You could write it:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> dollars = <span class="hljs-number">10</span>
<span class="hljs-keyword">const</span> conversionRate = <span class="hljs-number">1.1</span>
<span class="hljs-keyword">const</span> euros = dollars * conversionRate
</code></pre>
<p>This code is a bit weak because we've statically defined the conversionRate. It would be better if we didn't have to define this value statically but instead could be determined whenever you accessed conversionRate (since currency exchange rates flucuate constantly.) What if we did:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> dollars = <span class="hljs-number">10</span>
<span class="hljs-keyword">const</span> conversionRate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">1.1</span> }
<span class="hljs-keyword">const</span> euros = dollars * conversionRate()
</code></pre>
<p>Now we've wrapped conversionRate in a function. Even though the answer is unchanged, conversion is now a black box that we can swap out that 1.1 whenever. The value of the return of conversionRate isn't set until that function is actually called. conversionRate is now a <strong>thunk</strong>. It's a function wrapping a value.</p>
<p>The above is a silly example, but it with Redux this becomes a powerfuly feature. Instead of determining what action object you're going to dispatch at write time, you can determine what you're going dispatch conditionally or asynchronously. redux-thunk even let's you dispatch multiple actions! This can be useful if you have one action that leads to multiple, cascading changes. Super useful. So let's go change the Details page to use redux-thunk instead of local state. First, let's go include the redux-thunk middleware. Go store.js:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// @flow</span>
<span class="hljs-keyword">import</span> { createStore, compose, applyMiddleware } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>; <span class="hljs-comment">// add applyMiddleware</span>
<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-thunk'</span>; <span class="hljs-comment">// import</span>
<span class="hljs-keyword">import</span> rootReducer <span class="hljs-keyword">from</span> <span class="hljs-string">'./reducers'</span>;

<span class="hljs-keyword">const</span> store = createStore(
  rootReducer,
  compose(
    applyMiddleware(thunk), <span class="hljs-comment">// middleware</span>
    <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span>.devToolsExtension !== <span class="hljs-string">'undefined'</span> ? <span class="hljs-built_in">window</span>.devToolsExtension() : <span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f
  )
);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;
</code></pre>
<p>This is how you add more middlewares! Okay, so let's go add the <em>sync</em> action to make it so we can store omdbData in our data store. This is a good distinction to make: you still will only modify your state via reducers, and reducers are only kicked off via dispatching action <em>synchronously</em> to your root reducer. Always. So what we're doing is kicking off an async action which when it finishes will dispatch a sync action to the root reducer. We're just adding another step. So let's do our sync action. Go to actions.js:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ADD_API_DATA = <span class="hljs-string">'ADD_API_DATA'</span>;
</code></pre>
<p>Go to types.js</p>
<pre><code class="language-javascript"><span class="hljs-comment">// new action type</span>
declare type ActionType = <span class="hljs-string">'SET_SEARCH_TERM'</span> | <span class="hljs-string">'ADD_API_DATA'</span>;

<span class="hljs-comment">// new action</span>
<span class="hljs-keyword">export</span> type Action = ActionT&lt;<span class="hljs-string">'SET_SEARCH_TERM'</span>, string&gt; | ActionT&lt;<span class="hljs-string">'ADD_API_DATA'</span>, Show&gt;;
</code></pre>
<p>We're expanding how many different types of actions we can have.</p>
<p>Now go to reducers.js:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// at top</span>
<span class="hljs-keyword">import</span> { SET_SEARCH_TERM, ADD_API_DATA } <span class="hljs-keyword">from</span> <span class="hljs-string">'./actions'</span>;

<span class="hljs-keyword">const</span> DEFAULT_STATE = {
  <span class="hljs-attr">searchTerm</span>: <span class="hljs-string">''</span>,
  <span class="hljs-attr">apiData</span>: {}
};

<span class="hljs-comment">// add new reducer</span>
<span class="hljs-keyword">const</span> apiData = <span class="hljs-function">(<span class="hljs-params">state = {}, action: Action</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (action.type === ADD_API_DATA) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, state, { [action.payload.imdbID]: action.payload });
  }
  <span class="hljs-keyword">return</span> state;
};

<span class="hljs-comment">// add new reducer</span>
<span class="hljs-keyword">const</span> rootReducer = combineReducers({ searchTerm, apiData });
</code></pre>
<p>Doing some deep merging, but really nothing new here.</p>
<p>You can can totally do this with the other style of reducers we were doing but as you can see you get really clean code this way. We should also talk about type refinement at this point and <em>why</em> we went with the combineReducers style of writing Redux. There, where we check to see if action.type is ADD_API_DATA is called a type refinement in the eyes of Flow. As soon as we enter the body of that if statement, we are <strong>positive</strong> that the payload of that action is a Show and we're free to access all the data that a Show should have. We're positive because that's what our types dictate that to us. If we try to access <code>action.payload.imdbID</code> outside of that if statement, you'll get a Flow error because we are not yet certain of its type. It's a bit burdensome to get to this point but that assurance of the types is going to save you a bunch of run time errors.</p>
<p>Go to actionCreators.js:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;
<span class="hljs-keyword">import</span> { SET_SEARCH_TERM, ADD_API_DATA } <span class="hljs-keyword">from</span> <span class="hljs-string">'./actions'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setSearchTerm</span>(<span class="hljs-params">searchTerm: string</span>) </span>{
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">type</span>: SET_SEARCH_TERM, <span class="hljs-attr">payload</span>: searchTerm };
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAPIData</span>(<span class="hljs-params">apiData: Show</span>) </span>{
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">type</span>: ADD_API_DATA, <span class="hljs-attr">payload</span>: apiData };
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAPIDetails</span>(<span class="hljs-params">imdbID: string</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">dispatch: <span class="hljs-built_in">Function</span></span>) =&gt;</span> {
    axios
      .get(<span class="hljs-string">`http://localhost:3000/<span class="hljs-subst">${imdbID}</span>`</span>)
      .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
        dispatch(addAPIData(response.data));
      })
      .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'axios error'</span>, error); <span class="hljs-comment">// eslint-disable-line no-console</span>
      });
  };
}
</code></pre>
<p>First we add an action creator for our sync action, addAPIData. This is personal preference but I always make action creators that dispatch object a separate function. I could have done this directly inside of getOMDBDetails (and many people do) but I like keeping it separate for code organization and reuseability.</p>
<p>So let's unpack getAPIDetails. First this is to notice that it's a function that returns a function, a thunk. Redux will call this returned function (you call the outer one and pass that to dipatch) and pass into this returned function a dispatch function and a getState function. We don't need getState, but if your actionCreator needs to refer to the state of the Redux store, you'd call this function.</p>
<p>Inside of the returned function, we make our AJAX call and then dispatch an action via the addAPIData action creator with the new data. That's it! This is a pretty simple (and common) application of thunk, but you can get much more robust with it. Since you have a dispatch function, you're free to dispatch multiple actions, or not dispatch any at all, or conditionally dispatch one/many/none. Okay, so now head to Details.jsx to integrate it.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// new imports</span>
<span class="hljs-keyword">import</span> { connect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;
<span class="hljs-keyword">import</span> { getOMDBDetails } <span class="hljs-keyword">from</span> <span class="hljs-string">'./actionCreators'</span>;

<span class="hljs-comment">// delete axios import</span>

<span class="hljs-comment">// more propTypes (outside of show)</span>
props: {
  <span class="hljs-attr">rating</span>: string,
  <span class="hljs-attr">getAPIData</span>: <span class="hljs-built_in">Function</span>,
  <span class="hljs-attr">show</span>: Show
};

<span class="hljs-comment">// replace componentDidMount</span>
componentDidMount() {
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.props.rating) {
    <span class="hljs-keyword">this</span>.props.getAPIData();
  }
}

<span class="hljs-comment">// change state to props in render</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.props.rating) {
      rating = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{this.props.rating}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span>

<span class="hljs-comment">// replace export at bottom</span>
<span class="hljs-keyword">const</span> mapStateToProps = <span class="hljs-function">(<span class="hljs-params">state, ownProps</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> apiData = state.apiData[ownProps.show.imdbID] ? state.apiData[ownProps.show.imdbID] : {};
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">rating</span>: apiData.rating
  };
};

<span class="hljs-keyword">const</span> mapDispatchToProps = <span class="hljs-function">(<span class="hljs-params">dispatch: <span class="hljs-built_in">Function</span>, ownProps</span>) =&gt;</span> ({
  getAPIData() {
    dispatch(getAPIDetails(ownProps.show.imdbID));
  }
});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Details);
</code></pre>
<p>Okay, so now we have an interesting side effect of moving from React to Redux: when we were in React whenever we navigated away from a Details page, we lost the data we requested from the API and we'd have to re-request it anew every time we navigated to the page. Now since we've centralized to Redux, this data will survive page transitions. This means we need to be smart and only request data when we actually don't have it, hence the conditional in the componentDidMount method. If we already have data, no need to dispatch the action!</p>
<p>In the mapStateToProps, we're including the ownProps parameter. This is the props being passed down from its parent component which we need to select the correct show to pass in as props. It also has the benefit of making connect subscribe to props change so that mapStateToProps will change as the props change. If we suddenly switched the imdbID being passed in, this would still work just fine.</p>
<p>That's it! That's async Redux, or at least the simplest form of it. Like I alluded to earlier, there are several other ways of accomplishing async Redux. The other popular options include redux-promise where you dispatch promises, redux-observable where you dispatch observables, and redux-sagas where dispatch generators.</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>So we broke all of our tests. They all fail now. High five! This is a big reason why I'm hesitant to test UI code: I find my tests break all the time just because I'm rewriting markup or other code. Nonetheless, let's refix our tests and add two for Redux. As opposed to testing React which I don't do much of, I test the hell out of my Redux code. Redux code is very testable by design and you should cover all or nearly-all of your reducers with tests.</p>
<p>At the end of Search.jsx add:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Unwrapped = Search
</code></pre>
<p>We need an &quot;unconnected&quot; version of Search to test. We're decoupling this from Redux so we can just test the React portion. It will still work without Redux as long as we pass in proper parameters. Go to Search.spec.jsx.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// import the new Unwrapped Search as just Search</span>
<span class="hljs-keyword">import</span> Search, { Unwrapped <span class="hljs-keyword">as</span> UnwrappedSearch } <span class="hljs-keyword">from</span> <span class="hljs-string">'../Search'</span>;

<span class="hljs-comment">// in the first test, change the shallow call</span>
<span class="hljs-keyword">const</span> component = shallow(&lt;UnwrappedSearch shows={preload.shows} searchTerm='' /&gt;);

// in the second test, change the shallow call
const component = shallow(&lt;UnwrappedSearch shows={preload.shows} searchTerm='' /&gt;);

// go ahead and comment out the last test so we can test these first two first
</code></pre>
<p>Once we provide the proper params, these tests will be able to pass again. The snapshot is going to fail because we wrapped Header with a connect but go ahead and run <code>npm run update-test</code> to take care of that.</p>
<p>Since the last test tests the integration of Header and Search which were previously married together, we're going to need to do two things: switch our render to be able to render Header inside of Search instead of just stubbing it out and we're going to have to bring in Redux and integrate that.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// imports at top</span>
<span class="hljs-keyword">import</span> { Provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;
<span class="hljs-keyword">import</span> { MemoryRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;
<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'../store'</span>;
<span class="hljs-keyword">import</span> { setSearchTerm } <span class="hljs-keyword">from</span> <span class="hljs-string">'../actionCreators'</span>;
<span class="hljs-keyword">import</span> { shallow, render } <span class="hljs-keyword">from</span> <span class="hljs-string">'enzyme'</span> <span class="hljs-comment">// add render import</span>

<span class="hljs-comment">// replace last test</span>
test(<span class="hljs-string">'Search should render correct amount of shows based on search'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> searchWord = <span class="hljs-string">'New York'</span>;
  store.dispatch(setSearchTerm(searchWord));
  <span class="hljs-keyword">const</span> component = render(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">MemoryRouter</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Search</span> <span class="hljs-attr">shows</span>=<span class="hljs-string">{preload.shows}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">MemoryRouter</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span>
  );
  const showCount = preload.shows.filter(show =&gt;
    `${show.title.toUpperCase()} ${show.description.toUpperCase()}`.includes(searchWord.toUpperCase())
  ).length;
  expect(showCount).toEqual(component.find('.show-card').length);
});
</span></code></pre>
<p>We need to simulate events to Redux instead of to the DOM. Ultimately this isn't a big deal since you should be testing that action creator individually anyway. We also need to use Provider to make Redux work for Header since that's how Header and Search communicate now. Also, we can't do the ShowCard component trick anymore with render since it's not stubbing out ShowCard so we're just checking for the CSS class instead.</p>
<p>Since our ShowCard is using styled-components, we don't know what that CSS class is actually going to be. Luckily, we can add our own class on there. Go to ShowCard.jsx and add:</p>
<pre><code class="language-javascript">// replace wrapper
&lt;Wrapper className="show-card" to={`/details/${this.props.imdbID}`}&gt;
  […]
&lt;/Wrapper&gt;
</code></pre>
<p>Notice we also have to bring in react-router's MemoryRouter too. Since ShowCard has a Link in it, it depnds on a router being available. Since we're not in the DOM and not testing router-related functionality, it's enough to use the MemoryRouter which will allow it to work without having a DOM present. Super useful.</p>
<p>There's a layer deeper that you can go with Enzyme: static rendering with <a href="http://cheeriojs.github.io/cheerio/">Cheerio</a>. If you need to do serious manipulation, this is the tool you need to go with. Be forewarned this slows down startup a lot since it brings in jsdom and it is slow as 💩 to start up.</p>
<p>Cool! Let's go test Redux now.</p>
<p>One of the primary reasons to use Redux is how testable it is. It was a big part of its design. Redux makes you create <a href="http://www.nicoespeon.com/en/2015/01/pure-functions-javascript/">pure functions</a>. These functions are then able to pulled out and thoroughly tested. And, lucky for us, Redux dev tools now lets you generate test automatically! Open Search and paste the word &quot;orange&quot; in there. We paste it so it's one atomic operation. Open the Redux dev tools and select the last action. Click on the test tab. You'll see an automatically generated test! Copy that and paste it into reducers.spec.js. You may have to mess with the paths to get it correct. You also may have to modify the let to be a const to get ESLint to shut up. I also like to name the tests after their action name.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> reducers <span class="hljs-keyword">from</span> <span class="hljs-string">'../reducers'</span>;

test(<span class="hljs-string">'SET_SEARCH_TERM'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> state = reducers({ <span class="hljs-attr">searchTerm</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">apiData</span>: {} }, { <span class="hljs-attr">type</span>: <span class="hljs-string">'SET_SEARCH_TERM'</span>, <span class="hljs-attr">payload</span>: <span class="hljs-string">'orange'</span> });
  expect(state).toEqual({ <span class="hljs-attr">searchTerm</span>: <span class="hljs-string">'orange'</span>, <span class="hljs-attr">apiData</span>: {} });
});
</code></pre>
<p>Free tests. All we have to do is recreate what we want to test, copy, paste, and commit! Pretty slick. In this particular case, it's not terribly interesting. But you can't beat how low effort it is to get a test out the door. And if you have to later throw this test away you won't care because it was a minute to create start-to-finish. And if you get more complex Redux actions you can save <em>a lot</em> of time doing this. Let's also grab the @@INIT action to make sure we bootstrap the way we think.</p>
<pre><code class="language-javascript">test(<span class="hljs-string">'@@INIT'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> state = reducers(<span class="hljs-literal">undefined</span>, {});
  expect(state).toEqual({ <span class="hljs-attr">searchTerm</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">apiData</span>: {} });
});
</code></pre>
<p>Add one more for ADD_API_DATA after navigating to Details page:</p>
<pre><code class="language-javascript">test(<span class="hljs-string">'ADD_API_DATA'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> state = reducers(
    { <span class="hljs-attr">searchTerm</span>: <span class="hljs-string">'orange'</span>, <span class="hljs-attr">apiData</span>: {} },
    {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'ADD_API_DATA'</span>,
      <span class="hljs-attr">payload</span>: {
        <span class="hljs-attr">rating</span>: <span class="hljs-string">'0.8'</span>,
        <span class="hljs-attr">title</span>: <span class="hljs-string">'Orange Is the New Black'</span>,
        <span class="hljs-attr">year</span>: <span class="hljs-string">'2013–'</span>,
        <span class="hljs-attr">description</span>: <span class="hljs-string">'The story of Piper Chapman, a woman in her thirties who is sentenced to fifteen months in prison after being convicted of a decade-old crime of transporting money for her drug-dealing girlfriend.'</span>,
        <span class="hljs-attr">poster</span>: <span class="hljs-string">'oitnb.jpg'</span>,
        <span class="hljs-attr">imdbID</span>: <span class="hljs-string">'tt2372162'</span>,
        <span class="hljs-attr">trailer</span>: <span class="hljs-string">'th8WT_pxGqg'</span>
      }
    }
  );
  expect(state).toEqual({
    <span class="hljs-attr">searchTerm</span>: <span class="hljs-string">'orange'</span>,
    <span class="hljs-attr">apiData</span>: {
      <span class="hljs-attr">tt2372162</span>: {
        <span class="hljs-attr">rating</span>: <span class="hljs-string">'0.8'</span>,
        <span class="hljs-attr">title</span>: <span class="hljs-string">'Orange Is the New Black'</span>,
        <span class="hljs-attr">year</span>: <span class="hljs-string">'2013–'</span>,
        <span class="hljs-attr">description</span>: <span class="hljs-string">'The story of Piper Chapman, a woman in her thirties who is sentenced to fifteen months in prison after being convicted of a decade-old crime of transporting money for her drug-dealing girlfriend.'</span>,
        <span class="hljs-attr">poster</span>: <span class="hljs-string">'oitnb.jpg'</span>,
        <span class="hljs-attr">imdbID</span>: <span class="hljs-string">'tt2372162'</span>,
        <span class="hljs-attr">trailer</span>: <span class="hljs-string">'th8WT_pxGqg'</span>
      }
    }
  });
});
</code></pre>
<p>Let's go test our actionCreators. Create a new spec called <code>actionCreators.spec.js</code> and add this:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">import</span> { setSearchTerm, addAPIData } <span class="hljs-keyword">from</span> <span class="hljs-string">'../actionCreators'</span>;

test(<span class="hljs-string">'setSearchTerm'</span>, () =&gt; {
  expect(setSearchTerm(<span class="hljs-string">'New York'</span>)).toMatchSnapshot();
});

test(<span class="hljs-string">'addAPIData'</span>, () =&gt; {
  expect(
    addAPIData({
      <span class="hljs-attr">rating</span>: <span class="hljs-string">'0.8'</span>,
      <span class="hljs-attr">title</span>: <span class="hljs-string">'Orange Is the New Black'</span>,
      <span class="hljs-attr">year</span>: <span class="hljs-string">'2013–'</span>,
      <span class="hljs-attr">description</span>: <span class="hljs-string">'The story of Piper Chapman, a woman in her thirties who is sentenced to fifteen months in prison after being convicted of a decade-old crime of transporting money for her drug-dealing girlfriend.'</span>,
      <span class="hljs-attr">poster</span>: <span class="hljs-string">'oitnb.jpg'</span>,
      <span class="hljs-attr">imdbID</span>: <span class="hljs-string">'tt2372162'</span>,
      <span class="hljs-attr">trailer</span>: <span class="hljs-string">'th8WT_pxGqg'</span>
    })
  ).toMatchSnapshot();
});
</code></pre>
<p>Since actions are just objects that easily serializable, snapshots are perfect to test them. This way if their shape ever changes, you'll instantly know (if it somehow slips by Flow) and it'll be easy to update if that's anticipated.</p>
<p>Okay, now let's test our thunk. This is a bit trickier to test since we need to handle asynchronous behavior and mock out AJAX requests. Luckily [moxios][moxios] is a nice helper for axios for testing. Let's take a look at what that looks like:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// at the top</span>
<span class="hljs-keyword">import</span> moxios <span class="hljs-keyword">from</span> <span class="hljs-string">'moxios'</span>;

<span class="hljs-comment">// move this to an object that we can reuse</span>
<span class="hljs-keyword">const</span> oitnb = {
  <span class="hljs-attr">rating</span>: <span class="hljs-string">'0.8'</span>,
  <span class="hljs-attr">title</span>: <span class="hljs-string">'Orange Is the New Black'</span>,
  <span class="hljs-attr">year</span>: <span class="hljs-string">'2013–'</span>,
  <span class="hljs-attr">description</span>: <span class="hljs-string">'The story of Piper Chapman, a woman in her thirties who is sentenced to fifteen months in prison after being convicted of a decade-old crime of transporting money for her drug-dealing girlfriend.'</span>,
  <span class="hljs-attr">poster</span>: <span class="hljs-string">'oitnb.jpg'</span>,
  <span class="hljs-attr">imdbID</span>: <span class="hljs-string">'tt2372162'</span>,
  <span class="hljs-attr">trailer</span>: <span class="hljs-string">'th8WT_pxGqg'</span>
};

<span class="hljs-comment">// modify the addAPIData test to use the object</span>
test(<span class="hljs-string">'addAPIData'</span>, () =&gt; {
  expect(addAPIData(oitnb)).toMatchSnapshot();
});

<span class="hljs-comment">// at the bottom</span>
test(<span class="hljs-string">'getAPIDetails'</span>, (done: <span class="hljs-built_in">Function</span>) =&gt; {
  <span class="hljs-keyword">const</span> dispatchMock = jest.fn();
  moxios.withMock(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    getAPIDetails(oitnb.imdbID)(dispatchMock);
    moxios.wait(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> request = moxios.requests.mostRecent();
      request
        .respondWith({
          <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,
          <span class="hljs-attr">response</span>: oitnb
        })
        .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
          expect(request.url).toEqual(<span class="hljs-string">`http://localhost:3000/<span class="hljs-subst">${oitnb.imdbID}</span>`</span>);
          expect(dispatchMock).toBeCalledWith(addAPIData(oitnb));
          done();
        });
    });
  });
});
</code></pre>
<p>Notice we're providing a <code>done</code> function to the test. This is because this is an async test and without it the test will complete synchronously. We need it to wait until the async behavior completes.</p>
<p>The first thing in the function we're doing is creating a spy function with Jest. This is the same as what [sinon][sinon] does for you: it's a function we can use to make sure that the callbacks are being called with the write parameters and the correct amount of times.</p>
<p>Next we're calling <code>moxios.withMock</code>. This is specific to moxios and something you actually could achieve with Jest's mocking capabilites alone but since moxios exists it's an easy companion to use with axios. This will stub out the axios require inside of actionCreators.js and make it so it's mocked instead of actually trying to make an AJAX call.</p>
<p>Inside we invoke the actionCreators, first creating the thunk with the correct ID, then invoking the returned thunk with the mocked dispatch function. A bit weird, but it makes sense. The actionCreators returns a function (which typically Redux calls for you with its dispatch function) and we call it with our mock dispatch function.</p>
<p>After we invoke the thunk, we have to wait since it's async code, hence the wait function. Once inside there, we can inspect the moxios request, tell it what to respond with, and then examine that response after the promise it returns completes. This can be confusing due to the multiple levels of async we're dealing with to achieve the ability to test the dispatch params and the URL axios is calling, but I'd say with it. Now we can be certain the API request is happening to the URL we anticipate and it's creating appropriate action based on the API call made.</p>
<p>That's how you create a test for a thunk! As you may see, when you introduce Redux to a React codebase, it makes the data layers a bit easier to test (testing that async behavior in React would be tough; it's not too bad in Redux) but at the cost of making React much tougher to test due to the Redux integration. Again, make your own judgment call as to what's important to you.</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>Universal rendering, or the artist formerly known as isomorphic rendering. The idea here is that you server-side prerender your code so that when it gets down to the client, your browser can <strong>instantly</strong> show the markup while your app bootstraps in the background. It makes everything feel very instantaneous.</p>
<p>With just vanilla React, universal rendering is a cinch. Check out the <a href="https://github.com/btholt/es6-react-pres/blob/master/completed/app.js">whole node file from another one of my workshops</a>. It does server-side rendering in just a few lines.</p>
<p>It's not quite so simple now that we have routing involved. We don't want to have to duplicate all of our routing info that we wrote for react-router. Rather, if possible, we just want to reuse the routes we already built for react-router. So let's do that (with some refactoring.)</p>
<p>First thing you typically need to do when getting ready to implements server-side rendering (SSR) is split browser concerns and app concerns. The key is anything in the <em>initial render path</em> cannot reference anything in the DOM or window. We can't make AJAX calls, reference the window, or anything else browser specific. All the browser specific code has to live in ClientApp.jsx (which won't get included in Node,) componentDidMount (which doesn't get called,) or behind some sort of <code>if (window)</code> conditional.</p>
<p>We're pretty close to good as is. The only thing we need to do is move BrowserRouter from App to ClientApp. In Node we'll use a ServerRouter so we need the Browser one to only to get included client-side. So remove BrowserRouter from App altogether and wrap the <code>&lt;App /&gt;</code> in the render call in ClientApp with <code>&lt;BrowserRouter&gt;&lt;/BrowserRouter&gt;</code> (after importing it.)</p>
<p>That should be enough. ClientApp should look like:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { render } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> { BrowserRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>;

<span class="hljs-keyword">const</span> renderApp = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  render(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span></span>,
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'app'</span>)
  );
};
renderApp();

<span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span>.hot) {
  <span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">'./App'</span>, () =&gt; {
    renderApp();
  });
}
</code></pre>
<p>You may still have the Perf stuff in there. At this point you should take it out.</p>
<p>Now all browser concerns lie in ClientApp and the general app has been split out and is ready to be server renderered. We'll use a special ServerRouter for server rendering so that's why we put the BrowserRouter inside of ClientApp.</p>
<p>Okay, now we need to go make it so that index.html can be used as a template. There <code>Number.POSITIVE_INFINITY</code> ways of doing this, I'm just going to show you one (hopefully easy) way of doing it: with Lodash. First go add the <code>&lt;%= body %&gt;</code> template tag to index.html inside of <code>#app</code> like so:</p>
<pre><code class="language-javascript">&lt;!DOCTYPE html&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>svideo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/public/style.css"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%=</span> <span class="hljs-attr">body</span> %&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">&amp;NegativeMediumSpace;script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/public/bundle.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</span></code></pre>
<p>This is <a href="https://lodash.com/docs#template">Lodash-specific templating</a>. We'll use it as we server-side render.</p>
<p>Go to .babelrc and add env, for server. For now it'll be the same as test (since we need Babel to make the modules to CommonJS here too) but we don't want to tie those together.</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"presets"</span>: [
    <span class="hljs-string">"react"</span>,
    [<span class="hljs-string">"env"</span>, {
      <span class="hljs-attr">"targets"</span>: {
        <span class="hljs-attr">"browsers"</span>: <span class="hljs-string">"last 2 versions"</span>
      },
      <span class="hljs-attr">"loose"</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">"modules"</span>: <span class="hljs-literal">false</span>
    }]
  ],
  <span class="hljs-attr">"plugins"</span>: [
    <span class="hljs-string">"react-hot-loader/babel"</span>,
    <span class="hljs-string">"babel-plugin-transform-decorators-legacy"</span>,
    <span class="hljs-string">"babel-plugin-transform-class-properties"</span>
  ],
  <span class="hljs-attr">"env"</span>: {
    <span class="hljs-attr">"server"</span>: {
      <span class="hljs-attr">"plugins"</span>: [<span class="hljs-string">"transform-es2015-modules-commonjs"</span>]
    },
    <span class="hljs-attr">"test"</span>: {
      <span class="hljs-attr">"plugins"</span>: [<span class="hljs-string">"transform-es2015-modules-commonjs"</span>]
    }
  }
}
</code></pre>
<p>Okay, let's create a server now! Create a server.js <em>outside</em> the js folder and put it just in the root directory of your project. Put:</p>
<pre><code class="language-javascript"><span class="hljs-comment">/* eslint no-console:0 */</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">'babel-register'</span>);

<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react'</span>);
<span class="hljs-keyword">const</span> ReactDOMServer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-dom/server'</span>);
<span class="hljs-keyword">const</span> ReactRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-router-dom'</span>);
<span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> App = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./js/App'</span>).default;

<span class="hljs-keyword">const</span> StaticRouter = ReactRouter.StaticRouter;
<span class="hljs-keyword">const</span> port = <span class="hljs-number">8080</span>;
<span class="hljs-keyword">const</span> baseTemplate = fs.readFileSync(<span class="hljs-string">'./index.html'</span>);
<span class="hljs-keyword">const</span> template = _.template(baseTemplate);

<span class="hljs-keyword">const</span> server = express();

server.use(<span class="hljs-string">'/public'</span>, express.static(<span class="hljs-string">'./public'</span>));

server.use(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> context = {};
  <span class="hljs-keyword">const</span> body = ReactDOMServer.renderToString(
    React.createElement(StaticRouter, { <span class="hljs-attr">location</span>: req.url, context }, React.createElement(App))
  );

  <span class="hljs-keyword">if</span> (context.url) {
    res.redirect(context.url);
  }

  res.write(template({ body }));
  res.end();
});

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`listening on <span class="hljs-subst">${port}</span>`</span>);
server.listen(port);
</code></pre>
<p>We're switching back to CommonJS here to work with Node; Node doesn't natively understand ES6 modules so we need to use CommonJS. We require in a bunch of stuff. We're using Lodash templates but that's a detail; I just did it since it's an easy way to template. There's ten billion other ways to do it. We do some static serving for our CSS and bundled JS. And then we do the magic of server side rendering.</p>
<p>The context object we're feeding into the StaticRouter is to handle the 404 and redirect cases.</p>
<p>babel-register at the top lets us require modules that need transpilation.</p>
<p>Okay. Let's run the app. Run in your CLI <code>npm run build</code> (to build your bundle) then run <code>NODE_ENV=server node server.js</code>. Make sure you re-run build because the webpack-dev-server doesn't necessarily re-write out the bundle.js. Okay, so now try going to localhost:5050. While you won't necessarily notice it loading quicker since you were developing locally, check out view source. You should see it ships with a bunch of markup which means your page will load <em>much</em> quicker on a slower connection since markup will start rendering before the JS is done downloading.</p>
<p>Congrats! You've done server-side rendering! Now, we messed up hot module reload. It'd be great if we didn't have to choose between SSR and HMR. And we don't! Let's go include that too. First go to your webpack config and let's change just one thing:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// replace the entry:</span>
entry: [<span class="hljs-string">'webpack-hot-middleware/client?path=/__webpack_hmr&amp;timeout=20000'</span>, <span class="hljs-string">'./js/ClientApp.jsx'</span>],
</code></pre>
<p>We need webpack to look for the webpack middleware instead of the dev server. After doing this, the dev server will not work and you can only use the server version. So let's go make the server work as well.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// more includes</span>
<span class="hljs-keyword">const</span> webpackDevMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-dev-middleware'</span>);
<span class="hljs-keyword">const</span> webpackHotMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-hot-middleware'</span>);
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>);
<span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./webpack.config'</span>);


<span class="hljs-comment">// after the creation of server, before server.use('public' …)</span>
<span class="hljs-keyword">const</span> compiler = webpack(config);
server.use(
  webpackDevMiddleware(compiler, {
    <span class="hljs-attr">publicPath</span>: config.output.publicPath
  })
);
server.use(webpackHotMiddleware(compiler));
</code></pre>
<p>Now you should be able to run <code>NODE_ENV=server node server.js</code> (or however you set environment variables in your shell, this works for bash) and get SSR and HMR! Let's go modify our dev command in package.json to use our server instead of webpack-dev-server.</p>
<pre><code class="language-json">"dev": "NODE_ENV=server nodemon server.js",
</code></pre>
<p><a href="https://github.com/remy/nodemon">Nodemon</a> is a dev helper tool that will automatically restart the server that we make changes to server.js. Shouldn't need it now but it's useful once you want to start changing server.js. So now try <code>yarn dev</code> and see if it works (make sure your webpack-dev-server is not running.) You should see everything working as expected.</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>So far all of our routing with react-router has synchronous which makes sense. When we detect that a user has requested a route, we already have that route in our bundle.js and we render and serve that to them. The logic follows.</p>
<p>However, as our app grows and grows, our bundle.js is going to get bigger and bigger in file size. Wouldn't it be better if you were on Search that it served you <em>just</em> the JavaScript you need for that page and none of the JS for Landing or Details? For example, Search doesn't need the axios client we brought in: that client can safely just be loaded on the Details page.</p>
<p>Enter webpack's code splitting ability. It's smart enough to know which files are required by which other files and thus if you choose to use webpack's async loading API (<code>import(…)</code>) then webpack will <em>automatically</em> start chunking your JS for you. What's more is we don't have to write the glue code that will download the chunks as we need them: webpack just does this for us. All we have to do is identify the modules that can be async by treating them as if they were. Really cool.</p>
<p>So we're going to treat all of our routes as async and luckily react-router is already instrumented for this for both server and client-side. So let's go make it happen! We're going to be using to do this. There are many ways to do this; I've just found this easiest to teach you. People right now like <a href="https://github.com/threepointone/react-modules">react-modules</a> despite it having some issues with server-side rendering.</p>
<p>Let's go create a component that will handle our asynchronous routes to contain all that craziness. Create a file called AsyncRoute and go there.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> Spinner <span class="hljs-keyword">from</span> <span class="hljs-string">'./Spinner'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncRoute</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">loaded</span>: <span class="hljs-literal">false</span>
  };
  componentDidMount() {
    <span class="hljs-keyword">this</span>.props.loadingPromise.then(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> {
      <span class="hljs-keyword">this</span>.component = <span class="hljs-built_in">module</span>.default;
      <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">loaded</span>: <span class="hljs-literal">true</span> });
    });
  }
  component = <span class="hljs-literal">null</span>;
  props: {
    <span class="hljs-attr">props</span>: mixed,
    <span class="hljs-attr">loadingPromise</span>: <span class="hljs-built_in">Promise</span>&lt;{ <span class="hljs-attr">default</span>: Class&lt;React.Component&lt;*, *, *&gt;&gt; }&gt;
  };
  render() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.loaded) {
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">this.component</span> {<span class="hljs-attr">...this.props.props</span>} /&gt;</span>;
    }
    return <span class="hljs-tag">&lt;<span class="hljs-name">Spinner</span> /&gt;</span>;
  }
}

export default AsyncRoute;
</span></code></pre>
<p>AsyncRoute is going to passed a promise which will resolve to a module. Once that promise has completed, that means the module is loaded and available. Then we can render it. Notice that we stick the module on this and not into state. Modules are large and it would slow down our component to have so much state. Furthermore we don't expect it to change. Before that we'll render a loading state. That's all we're going to do with AsyncRoute.</p>
<p>Now we need to enable Babel, Webpack, and Node to all understand the <code>import(…)</code> syntax. This is brand new and only stage 3. Thus we need to include a few more plugins. We need one just so Babel can understand import at all, and one to transform so Webpack will know to split there. Add the following to the top level plugins array:</p>
<pre><code class="language-javascript"><span class="hljs-string">"plugins"</span>: [
  <span class="hljs-string">"react-hot-loader/babel"</span>,
  <span class="hljs-string">"babel-plugin-syntax-dynamic-import"</span>,
  <span class="hljs-string">"babel-plugin-dynamic-import-webpack"</span>,
  <span class="hljs-string">"babel-plugin-transform-decorators-legacy"</span>,
  <span class="hljs-string">"babel-plugin-transform-class-properties"</span>
],
</code></pre>
<p>Go to App.jsx</p>
<pre><code class="language-javascript"><span class="hljs-comment">// replace Landing Match</span>
&lt;Route exact path=<span class="hljs-string">"/"</span> component={props =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AsyncRoute</span> <span class="hljs-attr">props</span>=<span class="hljs-string">{props}</span> <span class="hljs-attr">loadingPromise</span>=<span class="hljs-string">{import(</span>'<span class="hljs-attr">.</span>/<span class="hljs-attr">Landing</span>')} /&gt;</span>} /&gt;
</span></code></pre>
<p>So now we're using our AsyncRoute function to make Landing Async. First we import our route. Then we pull in our AsyncRoute and use it inside of Route. This is amazing since Webpack knows to perform a code split here and we get all the rest of that for free.</p>
<p>Let's talk about what sucks about this. Now, server-side rendered or not, we get a loading screen first thing. No matter what. Ideally we get this loading screen <em>sooner</em> but nonetheless that happens. There are ways around this but it involves either making some compromises by not server-side rendering properly and getting a <a href="https://stackoverflow.com/questions/34311221/what-is-checksum-in-react-and-how-to-use-it">checksum violation</a> or by greatly increasing the complexity of this by introducing the concept of module hydration where on the server you make sure to send down the bundle and the correct chunk at the same time and detect that on the client. For now I'm happy just introducing code-splitting to our app for now.</p>
<p>Also, in order for import() (or <a href="https://webpack.github.io/docs/code-splitting.html#commonjs-require-ensure">require.ensure</a>, which is the CommonJS version) to be able to code split, the parameter passed to it must be a string of the path. It cannot be a variable. Webpack is doing static analsysis of your code and cannot follow variables.</p>
<p>Open up your browser to /search (without hitting / first) and watch the network tab. Make sure your npm run watch and your npm run start are both running. You should see bundle.js being downloaded but you should also see 0.bundle.js being downloaded too. This is the chunks that Webpack is sending down piecemeal, meaning your route and associated modules are not included in the initial payload. This becomes a bigger and bigger deal as your app expands. Let's finish the rest of our async routes.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// delete Search and Details import</span>

<span class="hljs-comment">// replace Details and Search matches</span>
&lt;Route
  path=<span class="hljs-string">"/search"</span>
  component={props =&gt; (
    &lt;AsyncRoute loadingPromise={import('./Search')} props={Object.assign({ shows: preload.shows }, props)} /&gt;
  )}
/&gt;
&lt;Route
  path="/details/:id"
  component={(props: { match: Match }) =&gt; {
    const selectedShow = preload.shows.find((show: Show) =&gt; props.match.params.id === show.imdbID);
    return (
      &lt;AsyncRoute
        loadingPromise={import('./Details')}
        props={Object.assign({ show: selectedShow, match: {} }, props)}
      /&gt;
    );
  }}
/&gt;
</code></pre>
<p>Nothing too crazy here either. Just extendingo out the same ideas. Now try navigating around your app and watch the network tab. You should different bundles being pulled in. If you look at your terminal output, you'll see we actually haven't optimized too much: our main bundle is nearly a megabyte and the smaller bundles are between three and fifty kilobytes. Like I said, this is wonderful for big apps where you can section off where dependencies. For example the fifty kilobyte bundle is the only one that has axios. The rest of the app doesn't need it. But for our tiny React routes, this isn't super useful. And the ability to codesplit isn't free either: Webpack includes some glue code to make this work. So evaluate this tool carefully!</p>
<p>Our problem now is that we've broken hot module reload. Unfortunately, with Webpack in the state it's a choose-two situation with code-spliting, hot module replacement, and server side rendering. You can set up two different webpack configs since you only need code splitting on the front end and you only need HMR in dev: I leave that to you.</p>
<p>Lastly, let's set up our build for production. Go modify build in package.json's scripts to be:</p>
<pre><code class="language-json">"build": "webpack -p",
"build:dev": "webpack -d",
</code></pre>
<p><code>-p</code> optimizes Webpack for production with Uglify and builds React in production mode. <code>-d</code> builds in debug mode and includes much more verbose logging. The sizes you see for <code>-p</code> are minified and uglified (including tree shaking) but are not gzipped. Usually your server does that automatically.</p>
<p>Go modify your Webpack config's devtool line to be</p>
<pre><code class="language-javascript">devtool: process.env.NODE_ENV === <span class="hljs-string">'development'</span> ? <span class="hljs-string">'cheap-eval-source-map'</span> : <span class="hljs-literal">false</span>,
</code></pre>
<p>Source maps are huge and this will only ship them in dev. You'll also need to conditionally include the webpack middleware stuff: refactor to look like this:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>);

<span class="hljs-keyword">const</span> config = {
  <span class="hljs-attr">context</span>: __dirname,
  <span class="hljs-attr">entry</span>: [<span class="hljs-string">'./js/ClientApp.jsx'</span>],
  <span class="hljs-attr">devtool</span>: process.env.NODE_ENV === <span class="hljs-string">'development'</span> ? <span class="hljs-string">'cheap-eval-source-map'</span> : <span class="hljs-literal">false</span>,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.resolve(__dirname, <span class="hljs-string">'public'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>,
    <span class="hljs-attr">publicPath</span>: <span class="hljs-string">'/public/'</span>
  },
  <span class="hljs-attr">devServer</span>: {
    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">publicPath</span>: <span class="hljs-string">'/public/'</span>,
    <span class="hljs-attr">historyApiFallback</span>: <span class="hljs-literal">true</span>
  },
  <span class="hljs-attr">resolve</span>: {
    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">'.js'</span>, <span class="hljs-string">'.jsx'</span>, <span class="hljs-string">'.json'</span>]
  },
  <span class="hljs-attr">stats</span>: {
    <span class="hljs-attr">colors</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">reasons</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">chunks</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="hljs-keyword">new</span> webpack.NamedModulesPlugin()],
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">enforce</span>: <span class="hljs-string">'pre'</span>,
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.jsx?$/</span>,
        <span class="hljs-attr">loader</span>: <span class="hljs-string">'eslint-loader'</span>,
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.jsx?$/</span>,
        <span class="hljs-attr">loader</span>: <span class="hljs-string">'babel-loader'</span>
      }
    ]
  }
};

<span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">'development'</span>) {
  config.entry.unshift(<span class="hljs-string">'webpack-hot-middleware/client?path=/__webpack_hmr&amp;timeout=20000'</span>);
}

<span class="hljs-built_in">module</span>.exports = config;
</code></pre>
<p>Add the development env to your .babelrc</p>
<pre><code class="language-json">"development": {
  "plugins": ["transform-es2015-modules-commonjs"]
},
</code></pre>
<p>And now we can only run the dev middleware in dev, as well as gzip our output. This is often done at the reverse proxy layer (like Nginx) but let's do it here for fun. Refactor your server to be:</p>
<pre><code class="language-javascript"><span class="hljs-comment">//include</span>
<span class="hljs-keyword">const</span> compression = <span class="hljs-built_in">require</span>(<span class="hljs-string">'compression'</span>);

server.use(compression());
<span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">'development'</span>) {
  <span class="hljs-keyword">const</span> compiler = webpack(config);
  server.use(
    webpackDevMiddleware(compiler, {
      <span class="hljs-attr">publicPath</span>: config.output.publicPath
    })
  );
  server.use(webpackHotMiddleware(compiler));
}
</code></pre>
<p>This should get our first chunk down to about 105KB. Not bad. Let's see if we can press even harder with Preact.</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>

<article class="post">
  <section class="post-excerpt">
    <p>So this is a React work, why the 💩 are we talking about <a href="https://preactjs.com/">Preact</a>? Let me tell you why! Preact is amazing! Preact is an <em>almost</em> drop in replacement for React that is  <strong>much</strong> smaller in file size while maintaing nearly all the features and actually being faster (or so my limited, flawed benchmarking leads me to believe.) One thing is for sure though, it's much smaller!</p>
<p>It sounds just better, right? Well, it's certainly something you and your company should discuss. Preact is just 3KB gzipped; that's really small! React for comparison's sake is around 45KB, give or take 5KB. That's a huge difference! The way Preact is able to achieve a lot of the size difference is by cutting out some of the legacy bits of React, letting the browser do more heavy lifting, and focusing on a smaller API.</p>
<p>Speaking of a smaller API, we can't switch to Preact wholesale as-is right now; we're using the React and ReactDOM package everywhere.</p>
<p>So instead we're going to drop in the preact-compat library which backfills those APIs at the cost of adding 5KB to your payload; still a win. preact-compat gets you started on your migration; eventually you want to drop it and just be on Preact.</p>
<p>So we're going to super quick migrate to Preact for the client side. In webpack.config.js, add:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// inside resolve</span>
alias: {
  <span class="hljs-attr">react</span>: <span class="hljs-string">'preact-compat'</span>,
  <span class="hljs-string">'react-dom'</span>: <span class="hljs-string">'preact-compat'</span>
},

<span class="hljs-comment">// inside 'babel-loader' loader</span>
include: [
  path.resolve(<span class="hljs-string">'js'</span>),
  path.resolve(<span class="hljs-string">'node_modules/preact-compat/src'</span>)
]
</code></pre>
<p>The include parts is just telling babel-loader to only run on files that are in the js directory (our code) or in the preact-compat directory. We should have done this sooner since this will speed up your build by not running on every file in node_modules.</p>
<p>The alias bit is telling webpack that everytime in our app we ask for react or react-dom, to actually give it preact-compat (which itself encompasses Preact.) Now build your app for production and compare! In my local env, I'm seeing a difference of 51KB vs 105KB for production builds, gzipped. Not bad!!</p>
<p>Our server more-or-less works as is. It's not ideal; honestly you'd want Preact doing both server and client work, but this is good for now. If you want to make it work, you'll need to make Babel alias React to Preact instead of Webpack since that runs both client and server side whereas Webpack doesn't.</p>
<p>You can also do this for the <a href="https://infernojs.org/">Inferno</a> library as well. Similarly small and blazing fast, both Preact and Inferno are amazing.</p>

  </section>
  <footer class="post-meta">
    <time class="post-date" datetime=""></time>
    &middot;
    <span></span>
  </footer>
</article>





    
<nav class="pagination" role="navigation">
  

  <span class="page-number">1 of 1</span>

  
</nav>

  </main>

  <footer class="site-footer clearfix">
    <p class="footer-description">
      &copy; Complete Intro to React
    </p>
    <p class="footer-published">
      joyfully published by <a href="https://github.com/reptar/reptar">reptar</a>
    </p>
  </footer>

</body>
</html>
